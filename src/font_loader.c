/* font_loader.c generated by valac 0.18.1, the Vala compiler
 * generated from font_loader.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <gobject/gvaluecollector.h>


#define TYPE_FT_FACE (ft_face_get_type ())
#define FT_FACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FT_FACE, FT_Face))
#define FT_FACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FT_FACE, FT_FaceClass))
#define IS_FT_FACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FT_FACE))
#define IS_FT_FACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FT_FACE))
#define FT_FACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FT_FACE, FT_FaceClass))

typedef struct _FT_Face FT_Face;
typedef struct _FT_FaceClass FT_FaceClass;
typedef struct _FT_FacePrivate FT_FacePrivate;
typedef struct _ParamSpecFT_Face ParamSpecFT_Face;

#define TYPE_FT_LIBRARY (ft_library_get_type ())
#define FT_LIBRARY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FT_LIBRARY, FT_Library))
#define FT_LIBRARY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FT_LIBRARY, FT_LibraryClass))
#define IS_FT_LIBRARY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FT_LIBRARY))
#define IS_FT_LIBRARY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FT_LIBRARY))
#define FT_LIBRARY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FT_LIBRARY, FT_LibraryClass))

typedef struct _FT_Library FT_Library;
typedef struct _FT_LibraryClass FT_LibraryClass;
typedef struct _FT_LibraryPrivate FT_LibraryPrivate;
typedef struct _ParamSpecFT_Library ParamSpecFT_Library;

#define TYPE_FONT_LOADER (font_loader_get_type ())
#define FONT_LOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FONT_LOADER, FontLoader))
#define FONT_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FONT_LOADER, FontLoaderClass))
#define IS_FONT_LOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FONT_LOADER))
#define IS_FONT_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FONT_LOADER))
#define FONT_LOADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FONT_LOADER, FontLoaderClass))

typedef struct _FontLoader FontLoader;
typedef struct _FontLoaderClass FontLoaderClass;
typedef struct _FontLoaderPrivate FontLoaderPrivate;
#define _ft_library_unref0(var) ((var == NULL) ? NULL : (var = (ft_library_unref (var), NULL)))
#define _ft_face_unref0(var) ((var == NULL) ? NULL : (var = (ft_face_unref (var), NULL)))
typedef struct _ParamSpecFontLoader ParamSpecFontLoader;

struct _FT_Face {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FT_FacePrivate * priv;
};

struct _FT_FaceClass {
	GTypeClass parent_class;
	void (*finalize) (FT_Face *self);
};

struct _ParamSpecFT_Face {
	GParamSpec parent_instance;
};

struct _FT_Library {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FT_LibraryPrivate * priv;
};

struct _FT_LibraryClass {
	GTypeClass parent_class;
	void (*finalize) (FT_Library *self);
};

struct _ParamSpecFT_Library {
	GParamSpec parent_instance;
};

struct _FontLoader {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FontLoaderPrivate * priv;
};

struct _FontLoaderClass {
	GTypeClass parent_class;
	void (*finalize) (FontLoader *self);
};

struct _ParamSpecFontLoader {
	GParamSpec parent_instance;
};


static gpointer ft_face_parent_class = NULL;
static gpointer ft_library_parent_class = NULL;
static gpointer font_loader_parent_class = NULL;

gpointer ft_face_ref (gpointer instance);
void ft_face_unref (gpointer instance);
GParamSpec* param_spec_ft_face (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_ft_face (GValue* value, gpointer v_object);
void value_take_ft_face (GValue* value, gpointer v_object);
gpointer value_get_ft_face (const GValue* value);
GType ft_face_get_type (void) G_GNUC_CONST;
enum  {
	FT_FACE_DUMMY_PROPERTY
};
FT_Face* ft_face_new (void);
FT_Face* ft_face_construct (GType object_type);
static void ft_face_finalize (FT_Face* obj);
gpointer ft_library_ref (gpointer instance);
void ft_library_unref (gpointer instance);
GParamSpec* param_spec_ft_library (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_ft_library (GValue* value, gpointer v_object);
void value_take_ft_library (GValue* value, gpointer v_object);
gpointer value_get_ft_library (const GValue* value);
GType ft_library_get_type (void) G_GNUC_CONST;
enum  {
	FT_LIBRARY_DUMMY_PROPERTY
};
FT_Library* ft_library_new (void);
FT_Library* ft_library_construct (GType object_type);
static void ft_library_finalize (FT_Library* obj);
gint FT_Init_FreeType (FT_Library** alibrary);
gint FT_New_Face (FT_Library* library, const gchar* filepathname, glong face_index, FT_Face** aface);
cairo_font_face_t* cairo_ft_font_face_create_for_ft_face (FT_Face* face, gint load_flags);
gpointer font_loader_ref (gpointer instance);
void font_loader_unref (gpointer instance);
GParamSpec* param_spec_font_loader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_font_loader (GValue* value, gpointer v_object);
void value_take_font_loader (GValue* value, gpointer v_object);
gpointer value_get_font_loader (const GValue* value);
GType font_loader_get_type (void) G_GNUC_CONST;
enum  {
	FONT_LOADER_DUMMY_PROPERTY
};
cairo_font_face_t* font_loader_load (const gchar* path, GError** error);
FontLoader* font_loader_new (void);
FontLoader* font_loader_construct (GType object_type);
static void font_loader_finalize (FontLoader* obj);


FT_Face* ft_face_construct (GType object_type) {
	FT_Face* self = NULL;
	self = (FT_Face*) g_type_create_instance (object_type);
	return self;
}


FT_Face* ft_face_new (void) {
	return ft_face_construct (TYPE_FT_FACE);
}


static void value_ft_face_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_ft_face_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		ft_face_unref (value->data[0].v_pointer);
	}
}


static void value_ft_face_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = ft_face_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_ft_face_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_ft_face_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		FT_Face* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = ft_face_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_ft_face_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	FT_Face** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = ft_face_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_ft_face (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecFT_Face* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FT_FACE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_ft_face (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_FACE), NULL);
	return value->data[0].v_pointer;
}


void value_set_ft_face (GValue* value, gpointer v_object) {
	FT_Face* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_FACE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FT_FACE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		ft_face_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ft_face_unref (old);
	}
}


void value_take_ft_face (GValue* value, gpointer v_object) {
	FT_Face* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_FACE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FT_FACE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ft_face_unref (old);
	}
}


static void ft_face_class_init (FT_FaceClass * klass) {
	ft_face_parent_class = g_type_class_peek_parent (klass);
	FT_FACE_CLASS (klass)->finalize = ft_face_finalize;
}


static void ft_face_instance_init (FT_Face * self) {
	self->ref_count = 1;
}


static void ft_face_finalize (FT_Face* obj) {
	FT_Face * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FT_FACE, FT_Face);
}


GType ft_face_get_type (void) {
	static volatile gsize ft_face_type_id__volatile = 0;
	if (g_once_init_enter (&ft_face_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_ft_face_init, value_ft_face_free_value, value_ft_face_copy_value, value_ft_face_peek_pointer, "p", value_ft_face_collect_value, "p", value_ft_face_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FT_FaceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ft_face_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FT_Face), 0, (GInstanceInitFunc) ft_face_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType ft_face_type_id;
		ft_face_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FT_Face", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&ft_face_type_id__volatile, ft_face_type_id);
	}
	return ft_face_type_id__volatile;
}


gpointer ft_face_ref (gpointer instance) {
	FT_Face* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void ft_face_unref (gpointer instance) {
	FT_Face* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FT_FACE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


FT_Library* ft_library_construct (GType object_type) {
	FT_Library* self = NULL;
	self = (FT_Library*) g_type_create_instance (object_type);
	return self;
}


FT_Library* ft_library_new (void) {
	return ft_library_construct (TYPE_FT_LIBRARY);
}


static void value_ft_library_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_ft_library_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		ft_library_unref (value->data[0].v_pointer);
	}
}


static void value_ft_library_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = ft_library_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_ft_library_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_ft_library_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		FT_Library* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = ft_library_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_ft_library_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	FT_Library** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = ft_library_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_ft_library (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecFT_Library* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FT_LIBRARY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_ft_library (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_LIBRARY), NULL);
	return value->data[0].v_pointer;
}


void value_set_ft_library (GValue* value, gpointer v_object) {
	FT_Library* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_LIBRARY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FT_LIBRARY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		ft_library_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ft_library_unref (old);
	}
}


void value_take_ft_library (GValue* value, gpointer v_object) {
	FT_Library* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FT_LIBRARY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FT_LIBRARY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ft_library_unref (old);
	}
}


static void ft_library_class_init (FT_LibraryClass * klass) {
	ft_library_parent_class = g_type_class_peek_parent (klass);
	FT_LIBRARY_CLASS (klass)->finalize = ft_library_finalize;
}


static void ft_library_instance_init (FT_Library * self) {
	self->ref_count = 1;
}


static void ft_library_finalize (FT_Library* obj) {
	FT_Library * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FT_LIBRARY, FT_Library);
}


GType ft_library_get_type (void) {
	static volatile gsize ft_library_type_id__volatile = 0;
	if (g_once_init_enter (&ft_library_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_ft_library_init, value_ft_library_free_value, value_ft_library_copy_value, value_ft_library_peek_pointer, "p", value_ft_library_collect_value, "p", value_ft_library_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FT_LibraryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ft_library_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FT_Library), 0, (GInstanceInitFunc) ft_library_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType ft_library_type_id;
		ft_library_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FT_Library", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&ft_library_type_id__volatile, ft_library_type_id);
	}
	return ft_library_type_id__volatile;
}


gpointer ft_library_ref (gpointer instance) {
	FT_Library* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void ft_library_unref (gpointer instance) {
	FT_Library* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FT_LIBRARY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


cairo_font_face_t* font_loader_load (const gchar* path, GError** error) {
	cairo_font_face_t* result = NULL;
	FT_Library* library = NULL;
	FT_Face* face = NULL;
	FT_Library* _tmp0_ = NULL;
	FT_Library* _tmp1_;
	const gchar* _tmp2_;
	FT_Face* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _error_;
	gint _tmp5_;
	FT_Face* _tmp7_;
	cairo_font_face_t* _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	FT_Init_FreeType (&_tmp0_);
	_ft_library_unref0 (library);
	library = _tmp0_;
	_tmp1_ = library;
	_tmp2_ = path;
	_tmp4_ = FT_New_Face (_tmp1_, _tmp2_, (glong) 0, &_tmp3_);
	_ft_face_unref0 (face);
	face = _tmp3_;
	_error_ = _tmp4_;
	_tmp5_ = _error_;
	if (_tmp5_ != 0) {
		GError* _tmp6_;
		_tmp6_ = g_error_new_literal (G_FILE_ERROR, G_FILE_ERROR_ACCES, "");
		_inner_error_ = _tmp6_;
		g_propagate_error (error, _inner_error_);
		_ft_face_unref0 (face);
		_ft_library_unref0 (library);
		return NULL;
	}
	_tmp7_ = face;
	_tmp8_ = cairo_ft_font_face_create_for_ft_face (_tmp7_, 0);
	result = _tmp8_;
	_ft_face_unref0 (face);
	_ft_library_unref0 (library);
	return result;
}


FontLoader* font_loader_construct (GType object_type) {
	FontLoader* self = NULL;
	self = (FontLoader*) g_type_create_instance (object_type);
	return self;
}


FontLoader* font_loader_new (void) {
	return font_loader_construct (TYPE_FONT_LOADER);
}


static void value_font_loader_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_font_loader_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		font_loader_unref (value->data[0].v_pointer);
	}
}


static void value_font_loader_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = font_loader_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_font_loader_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_font_loader_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		FontLoader* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = font_loader_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_font_loader_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	FontLoader** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = font_loader_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_font_loader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecFontLoader* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FONT_LOADER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_font_loader (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FONT_LOADER), NULL);
	return value->data[0].v_pointer;
}


void value_set_font_loader (GValue* value, gpointer v_object) {
	FontLoader* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FONT_LOADER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FONT_LOADER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		font_loader_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		font_loader_unref (old);
	}
}


void value_take_font_loader (GValue* value, gpointer v_object) {
	FontLoader* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FONT_LOADER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FONT_LOADER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		font_loader_unref (old);
	}
}


static void font_loader_class_init (FontLoaderClass * klass) {
	font_loader_parent_class = g_type_class_peek_parent (klass);
	FONT_LOADER_CLASS (klass)->finalize = font_loader_finalize;
}


static void font_loader_instance_init (FontLoader * self) {
	self->ref_count = 1;
}


static void font_loader_finalize (FontLoader* obj) {
	FontLoader * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FONT_LOADER, FontLoader);
}


GType font_loader_get_type (void) {
	static volatile gsize font_loader_type_id__volatile = 0;
	if (g_once_init_enter (&font_loader_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_font_loader_init, value_font_loader_free_value, value_font_loader_copy_value, value_font_loader_peek_pointer, "p", value_font_loader_collect_value, "p", value_font_loader_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FontLoaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) font_loader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FontLoader), 0, (GInstanceInitFunc) font_loader_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType font_loader_type_id;
		font_loader_type_id = g_type_register_fundamental (g_type_fundamental_next (), "FontLoader", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&font_loader_type_id__volatile, font_loader_type_id);
	}
	return font_loader_type_id__volatile;
}


gpointer font_loader_ref (gpointer instance) {
	FontLoader* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void font_loader_unref (gpointer instance) {
	FontLoader* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FONT_LOADER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



