/* pitch_estimation.c generated by valac 0.18.1, the Vala compiler
 * generated from pitch_estimation.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include "kiss_fft.h"
#include "tools/kiss_fftr.h"
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_PITCH_ESTIMATION (pitch_estimation_get_type ())
#define PITCH_ESTIMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PITCH_ESTIMATION, PitchEstimation))
#define PITCH_ESTIMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PITCH_ESTIMATION, PitchEstimationClass))
#define IS_PITCH_ESTIMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PITCH_ESTIMATION))
#define IS_PITCH_ESTIMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PITCH_ESTIMATION))
#define PITCH_ESTIMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PITCH_ESTIMATION, PitchEstimationClass))

typedef struct _PitchEstimation PitchEstimation;
typedef struct _PitchEstimationClass PitchEstimationClass;
typedef struct _PitchEstimationPrivate PitchEstimationPrivate;
typedef struct _ParamSpecPitchEstimation ParamSpecPitchEstimation;

struct _PitchEstimation {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PitchEstimationPrivate * priv;
	gfloat* padded_data;
	gint padded_data_length1;
	gfloat* autocorr_data;
	gint autocorr_data_length1;
	gfloat* cepstrum;
	gint cepstrum_length1;
	gfloat* spectrum;
	gint spectrum_length1;
};

struct _PitchEstimationClass {
	GTypeClass parent_class;
	void (*finalize) (PitchEstimation *self);
};

struct _PitchEstimationPrivate {
	gfloat pitch;
	kiss_fft_cpx* fft1;
	gint fft1_length1;
	gint _fft1_size_;
	kiss_fft_cpx* fft2;
	gint fft2_length1;
	gint _fft2_size_;
	kiss_fftr_cfg fft1_cfg;
	kiss_fftr_cfg fft2_cfg;
	kiss_fftr_cfg ffti_cfg;
	gint sample_rate;
	gint fft1_length;
};

struct _ParamSpecPitchEstimation {
	GParamSpec parent_instance;
};


static gpointer pitch_estimation_parent_class = NULL;

gpointer pitch_estimation_ref (gpointer instance);
void pitch_estimation_unref (gpointer instance);
GParamSpec* param_spec_pitch_estimation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pitch_estimation (GValue* value, gpointer v_object);
void value_take_pitch_estimation (GValue* value, gpointer v_object);
gpointer value_get_pitch_estimation (const GValue* value);
GType pitch_estimation_get_type (void) G_GNUC_CONST;
#define PITCH_ESTIMATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PITCH_ESTIMATION, PitchEstimationPrivate))
enum  {
	PITCH_ESTIMATION_DUMMY_PROPERTY
};
PitchEstimation* pitch_estimation_new (gint sample_rate, gint data_length);
PitchEstimation* pitch_estimation_construct (GType object_type, gint sample_rate, gint data_length);
gfloat pitch_estimation_pitch_from_autocorrelation (PitchEstimation* self, gfloat* data, int data_length1);
static void pitch_estimation_normalize_and_center_clip (PitchEstimation* self, gfloat* data, int data_length1);
static gfloat pitch_estimation_parabolic (gfloat y0, gfloat y1, gfloat y2);
gfloat pitch_estimation_pitch_from_hps (PitchEstimation* self, gfloat* data, int data_length1);
gfloat pitch_estimation_pitch_from_fft (PitchEstimation* self, gfloat* data, int data_length1);
void window_gaussian (gfloat* response, int response_length1);
static void pitch_estimation_finalize (PitchEstimation* obj);


PitchEstimation* pitch_estimation_construct (GType object_type, gint sample_rate, gint data_length) {
	PitchEstimation* self = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gfloat* _tmp3_ = NULL;
	gint _tmp4_;
	gfloat* _tmp5_ = NULL;
	gint _tmp6_;
	kiss_fft_cpx* _tmp7_ = NULL;
	gint _tmp8_;
	kiss_fft_cpx* _tmp9_ = NULL;
	gint _tmp10_;
	kiss_fftr_cfg _tmp11_ = {0};
	gint _tmp12_;
	kiss_fftr_cfg _tmp13_ = {0};
	gint _tmp14_;
	kiss_fftr_cfg _tmp15_ = {0};
	gint _tmp16_;
	gfloat* _tmp17_ = NULL;
	gint _tmp18_;
	gfloat* _tmp19_ = NULL;
	self = (PitchEstimation*) g_type_create_instance (object_type);
	_tmp0_ = sample_rate;
	self->priv->sample_rate = _tmp0_;
	_tmp1_ = data_length;
	self->priv->fft1_length = _tmp1_;
	_tmp2_ = data_length;
	_tmp3_ = g_new0 (gfloat, (_tmp2_ / 2) + 1);
	self->spectrum = (g_free (self->spectrum), NULL);
	self->spectrum = _tmp3_;
	self->spectrum_length1 = (_tmp2_ / 2) + 1;
	_tmp4_ = data_length;
	_tmp5_ = g_new0 (gfloat, (_tmp4_ / 4) + 1);
	self->cepstrum = (g_free (self->cepstrum), NULL);
	self->cepstrum = _tmp5_;
	self->cepstrum_length1 = (_tmp4_ / 4) + 1;
	_tmp6_ = data_length;
	_tmp7_ = g_new0 (kiss_fft_cpx, (_tmp6_ / 2) + 1);
	self->priv->fft1 = (g_free (self->priv->fft1), NULL);
	self->priv->fft1 = _tmp7_;
	self->priv->fft1_length1 = (_tmp6_ / 2) + 1;
	self->priv->_fft1_size_ = self->priv->fft1_length1;
	_tmp8_ = data_length;
	_tmp9_ = g_new0 (kiss_fft_cpx, (_tmp8_ / 4) + 1);
	self->priv->fft2 = (g_free (self->priv->fft2), NULL);
	self->priv->fft2 = _tmp9_;
	self->priv->fft2_length1 = (_tmp8_ / 4) + 1;
	self->priv->_fft2_size_ = self->priv->fft2_length1;
	_tmp10_ = self->priv->fft1_length;
	_tmp11_ = kiss_fftr_alloc (_tmp10_, FALSE, NULL, NULL);
	kiss_fftr_free (self->priv->fft1_cfg);
	self->priv->fft1_cfg = _tmp11_;
	_tmp12_ = self->priv->fft1_length;
	_tmp13_ = kiss_fftr_alloc (_tmp12_ / 2, FALSE, NULL, NULL);
	kiss_fftr_free (self->priv->fft2_cfg);
	self->priv->fft2_cfg = _tmp13_;
	_tmp14_ = self->priv->fft1_length;
	_tmp15_ = kiss_fftr_alloc (_tmp14_, TRUE, NULL, NULL);
	kiss_fftr_free (self->priv->ffti_cfg);
	self->priv->ffti_cfg = _tmp15_;
	_tmp16_ = data_length;
	_tmp17_ = g_new0 (gfloat, _tmp16_ * 2);
	self->padded_data = (g_free (self->padded_data), NULL);
	self->padded_data = _tmp17_;
	self->padded_data_length1 = _tmp16_ * 2;
	_tmp18_ = data_length;
	_tmp19_ = g_new0 (gfloat, _tmp18_);
	self->autocorr_data = (g_free (self->autocorr_data), NULL);
	self->autocorr_data = _tmp19_;
	self->autocorr_data_length1 = _tmp18_;
	return self;
}


PitchEstimation* pitch_estimation_new (gint sample_rate, gint data_length) {
	return pitch_estimation_construct (TYPE_PITCH_ESTIMATION, sample_rate, data_length);
}


gfloat pitch_estimation_pitch_from_autocorrelation (PitchEstimation* self, gfloat* data, int data_length1) {
	gfloat result = 0.0F;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	kiss_fftr_cfg _tmp4_;
	gfloat* _tmp5_;
	gint _tmp5__length1;
	kiss_fft_cpx* _tmp6_;
	gint _tmp6__length1;
	kiss_fftr_cfg _tmp32_;
	kiss_fft_cpx* _tmp33_;
	gint _tmp33__length1;
	gfloat* _tmp34_;
	gint _tmp34__length1;
	gint low;
	gint x;
	gfloat* _tmp58_;
	gint _tmp58__length1;
	gfloat _tmp59_;
	gdouble threshold;
	gint _tmp74_;
	gfloat _tmp88_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = data;
	_tmp0__length1 = data_length1;
	pitch_estimation_normalize_and_center_clip (self, _tmp0_, _tmp0__length1);
	_tmp1_ = self->padded_data;
	_tmp1__length1 = self->padded_data_length1;
	_tmp2_ = data;
	_tmp2__length1 = data_length1;
	_tmp3_ = data;
	_tmp3__length1 = data_length1;
	memcpy (_tmp1_, _tmp2_, (gsize) (_tmp3__length1 * sizeof (gfloat)));
	_tmp4_ = self->priv->fft1_cfg;
	_tmp5_ = self->padded_data;
	_tmp5__length1 = self->padded_data_length1;
	_tmp6_ = self->priv->fft1;
	_tmp6__length1 = self->priv->fft1_length1;
	kiss_fftr (_tmp4_, _tmp5_, _tmp6_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gboolean _tmp8_;
				gint _tmp10_;
				kiss_fft_cpx* _tmp11_;
				gint _tmp11__length1;
				kiss_fft_cpx* _tmp12_;
				gint _tmp12__length1;
				gint _tmp13_;
				kiss_fft_cpx* _tmp14_;
				gint _tmp14__length1;
				gint _tmp15_;
				kiss_fft_cpx _tmp16_;
				kiss_fft_scalar _tmp17_;
				kiss_fft_cpx* _tmp18_;
				gint _tmp18__length1;
				gint _tmp19_;
				kiss_fft_cpx _tmp20_;
				kiss_fft_scalar _tmp21_;
				kiss_fft_cpx* _tmp22_;
				gint _tmp22__length1;
				gint _tmp23_;
				kiss_fft_cpx _tmp24_;
				kiss_fft_scalar _tmp25_;
				kiss_fft_cpx* _tmp26_;
				gint _tmp26__length1;
				gint _tmp27_;
				kiss_fft_cpx _tmp28_;
				kiss_fft_scalar _tmp29_;
				kiss_fft_cpx* _tmp30_;
				gint _tmp30__length1;
				gint _tmp31_;
				_tmp8_ = _tmp7_;
				if (!_tmp8_) {
					gint _tmp9_;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp7_ = FALSE;
				_tmp10_ = i;
				_tmp11_ = self->priv->fft1;
				_tmp11__length1 = self->priv->fft1_length1;
				if (!(_tmp10_ < _tmp11__length1)) {
					break;
				}
				_tmp12_ = self->priv->fft1;
				_tmp12__length1 = self->priv->fft1_length1;
				_tmp13_ = i;
				_tmp14_ = self->priv->fft1;
				_tmp14__length1 = self->priv->fft1_length1;
				_tmp15_ = i;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = _tmp16_.r;
				_tmp18_ = self->priv->fft1;
				_tmp18__length1 = self->priv->fft1_length1;
				_tmp19_ = i;
				_tmp20_ = _tmp18_[_tmp19_];
				_tmp21_ = _tmp20_.r;
				_tmp22_ = self->priv->fft1;
				_tmp22__length1 = self->priv->fft1_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				_tmp25_ = _tmp24_.i;
				_tmp26_ = self->priv->fft1;
				_tmp26__length1 = self->priv->fft1_length1;
				_tmp27_ = i;
				_tmp28_ = _tmp26_[_tmp27_];
				_tmp29_ = _tmp28_.i;
				_tmp12_[_tmp13_].r = (_tmp17_ * _tmp21_) + (_tmp25_ * _tmp29_);
				_tmp30_ = self->priv->fft1;
				_tmp30__length1 = self->priv->fft1_length1;
				_tmp31_ = i;
				_tmp30_[_tmp31_].i = (kiss_fft_scalar) 0;
			}
		}
	}
	_tmp32_ = self->priv->ffti_cfg;
	_tmp33_ = self->priv->fft1;
	_tmp33__length1 = self->priv->fft1_length1;
	_tmp34_ = self->autocorr_data;
	_tmp34__length1 = self->autocorr_data_length1;
	kiss_fftri (_tmp32_, _tmp33_, _tmp34_);
	{
		gint i;
		i = 1;
		{
			gboolean _tmp35_;
			_tmp35_ = TRUE;
			while (TRUE) {
				gboolean _tmp36_;
				gint _tmp38_;
				gfloat* _tmp39_;
				gint _tmp39__length1;
				gfloat* _tmp40_;
				gint _tmp40__length1;
				gint _tmp41_;
				gfloat* _tmp42_;
				gint _tmp42__length1;
				gint _tmp43_;
				gfloat* _tmp44_;
				gint _tmp44__length1;
				gfloat _tmp45_;
				_tmp36_ = _tmp35_;
				if (!_tmp36_) {
					gint _tmp37_;
					_tmp37_ = i;
					i = _tmp37_ + 1;
				}
				_tmp35_ = FALSE;
				_tmp38_ = i;
				_tmp39_ = self->autocorr_data;
				_tmp39__length1 = self->autocorr_data_length1;
				if (!(_tmp38_ < (_tmp39__length1 / 2))) {
					break;
				}
				_tmp40_ = self->autocorr_data;
				_tmp40__length1 = self->autocorr_data_length1;
				_tmp41_ = i;
				_tmp42_ = self->autocorr_data;
				_tmp42__length1 = self->autocorr_data_length1;
				_tmp43_ = i;
				_tmp44_ = self->autocorr_data;
				_tmp44__length1 = self->autocorr_data_length1;
				_tmp40_[_tmp41_] *= 1.f + (((gfloat) (_tmp42__length1 - _tmp43_)) / _tmp44__length1);
				_tmp45_ = _tmp40_[_tmp41_];
			}
		}
	}
	low = 0;
	x = 0;
	{
		gint i;
		i = 2;
		{
			gboolean _tmp46_;
			_tmp46_ = TRUE;
			while (TRUE) {
				gboolean _tmp47_;
				gint _tmp49_;
				gfloat* _tmp50_;
				gint _tmp50__length1;
				gfloat* _tmp51_;
				gint _tmp51__length1;
				gint _tmp52_;
				gfloat _tmp53_;
				gfloat* _tmp54_;
				gint _tmp54__length1;
				gint _tmp55_;
				gfloat _tmp56_;
				_tmp47_ = _tmp46_;
				if (!_tmp47_) {
					gint _tmp48_;
					_tmp48_ = i;
					i = _tmp48_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp49_ = i;
				_tmp50_ = self->autocorr_data;
				_tmp50__length1 = self->autocorr_data_length1;
				if (!(_tmp49_ < (_tmp50__length1 / 2))) {
					break;
				}
				_tmp51_ = self->autocorr_data;
				_tmp51__length1 = self->autocorr_data_length1;
				_tmp52_ = i;
				_tmp53_ = _tmp51_[_tmp52_];
				_tmp54_ = self->autocorr_data;
				_tmp54__length1 = self->autocorr_data_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_ - 1];
				if (_tmp53_ > _tmp56_) {
					gint _tmp57_;
					_tmp57_ = i;
					low = _tmp57_ - 1;
					break;
				}
			}
		}
	}
	_tmp58_ = self->autocorr_data;
	_tmp58__length1 = self->autocorr_data_length1;
	_tmp59_ = _tmp58_[0];
	threshold = 0.7 * _tmp59_;
	{
		gint _tmp60_;
		gint i;
		_tmp60_ = low;
		i = _tmp60_;
		{
			gboolean _tmp61_;
			_tmp61_ = TRUE;
			while (TRUE) {
				gboolean _tmp62_;
				gint _tmp64_;
				gfloat* _tmp65_;
				gint _tmp65__length1;
				gfloat* _tmp66_;
				gint _tmp66__length1;
				gint _tmp67_;
				gfloat _tmp68_;
				gdouble _tmp69_;
				_tmp62_ = _tmp61_;
				if (!_tmp62_) {
					gint _tmp63_;
					_tmp63_ = i;
					i = _tmp63_ + 1;
				}
				_tmp61_ = FALSE;
				_tmp64_ = i;
				_tmp65_ = self->autocorr_data;
				_tmp65__length1 = self->autocorr_data_length1;
				if (!(_tmp64_ < (_tmp65__length1 / 2))) {
					break;
				}
				_tmp66_ = self->autocorr_data;
				_tmp66__length1 = self->autocorr_data_length1;
				_tmp67_ = i;
				_tmp68_ = _tmp66_[_tmp67_];
				_tmp69_ = threshold;
				if (((gdouble) _tmp68_) > _tmp69_) {
					gfloat* _tmp70_;
					gint _tmp70__length1;
					gint _tmp71_;
					gfloat _tmp72_;
					gint _tmp73_;
					_tmp70_ = self->autocorr_data;
					_tmp70__length1 = self->autocorr_data_length1;
					_tmp71_ = i;
					_tmp72_ = _tmp70_[_tmp71_];
					threshold = (gdouble) _tmp72_;
					_tmp73_ = i;
					x = _tmp73_;
				}
			}
		}
	}
	_tmp74_ = x;
	if (_tmp74_ != 0) {
		gint _tmp75_;
		gfloat* _tmp76_;
		gint _tmp76__length1;
		gint _tmp77_;
		gfloat _tmp78_;
		gfloat* _tmp79_;
		gint _tmp79__length1;
		gint _tmp80_;
		gfloat _tmp81_;
		gfloat* _tmp82_;
		gint _tmp82__length1;
		gint _tmp83_;
		gfloat _tmp84_;
		gfloat _tmp85_ = 0.0F;
		gint _tmp86_;
		gfloat _tmp87_;
		_tmp75_ = x;
		_tmp76_ = self->autocorr_data;
		_tmp76__length1 = self->autocorr_data_length1;
		_tmp77_ = x;
		_tmp78_ = _tmp76_[_tmp77_ - 1];
		_tmp79_ = self->autocorr_data;
		_tmp79__length1 = self->autocorr_data_length1;
		_tmp80_ = x;
		_tmp81_ = _tmp79_[_tmp80_];
		_tmp82_ = self->autocorr_data;
		_tmp82__length1 = self->autocorr_data_length1;
		_tmp83_ = x;
		_tmp84_ = _tmp82_[_tmp83_ + 1];
		_tmp85_ = pitch_estimation_parabolic (_tmp78_, _tmp81_, _tmp84_);
		self->priv->pitch = _tmp75_ + _tmp85_;
		_tmp86_ = self->priv->sample_rate;
		_tmp87_ = self->priv->pitch;
		self->priv->pitch = (gfloat) (_tmp86_ / _tmp87_);
	}
	_tmp88_ = self->priv->pitch;
	result = _tmp88_;
	return result;
}


gfloat pitch_estimation_pitch_from_hps (PitchEstimation* self, gfloat* data, int data_length1) {
	gfloat result = 0.0F;
	g_return_val_if_fail (self != NULL, 0.0F);
	result = 0.0f;
	return result;
}


gfloat pitch_estimation_pitch_from_fft (PitchEstimation* self, gfloat* data, int data_length1) {
	gfloat result = 0.0F;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	kiss_fftr_cfg _tmp2_;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	kiss_fft_cpx* _tmp4_;
	gint _tmp4__length1;
	gint p;
	gfloat threshold;
	gfloat* _tmp42_;
	gint _tmp42__length1;
	gint _tmp43_;
	gfloat _tmp44_;
	gfloat* _tmp45_;
	gint _tmp45__length1;
	gint _tmp46_;
	gfloat _tmp47_;
	gfloat* _tmp48_;
	gint _tmp48__length1;
	gint _tmp49_;
	gfloat _tmp50_;
	gfloat _tmp51_ = 0.0F;
	gfloat ip;
	gint _tmp52_;
	gint _tmp53_;
	gint _tmp54_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = data;
	_tmp0__length1 = data_length1;
	pitch_estimation_normalize_and_center_clip (self, _tmp0_, _tmp0__length1);
	_tmp1_ = data;
	_tmp1__length1 = data_length1;
	window_gaussian (_tmp1_, _tmp1__length1);
	_tmp2_ = self->priv->fft1_cfg;
	_tmp3_ = data;
	_tmp3__length1 = data_length1;
	_tmp4_ = self->priv->fft1;
	_tmp4__length1 = self->priv->fft1_length1;
	kiss_fftr (_tmp2_, _tmp3_, _tmp4_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_;
				gint _tmp8_;
				kiss_fft_cpx* _tmp9_;
				gint _tmp9__length1;
				gfloat* _tmp10_;
				gint _tmp10__length1;
				gint _tmp11_;
				kiss_fft_cpx* _tmp12_;
				gint _tmp12__length1;
				gint _tmp13_;
				kiss_fft_cpx _tmp14_;
				kiss_fft_scalar _tmp15_;
				kiss_fft_cpx* _tmp16_;
				gint _tmp16__length1;
				gint _tmp17_;
				kiss_fft_cpx _tmp18_;
				kiss_fft_scalar _tmp19_;
				kiss_fft_cpx* _tmp20_;
				gint _tmp20__length1;
				gint _tmp21_;
				kiss_fft_cpx _tmp22_;
				kiss_fft_scalar _tmp23_;
				kiss_fft_cpx* _tmp24_;
				gint _tmp24__length1;
				gint _tmp25_;
				kiss_fft_cpx _tmp26_;
				kiss_fft_scalar _tmp27_;
				gfloat _tmp28_;
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp8_ = i;
				_tmp9_ = self->priv->fft1;
				_tmp9__length1 = self->priv->fft1_length1;
				if (!(_tmp8_ < _tmp9__length1)) {
					break;
				}
				_tmp10_ = self->spectrum;
				_tmp10__length1 = self->spectrum_length1;
				_tmp11_ = i;
				_tmp12_ = self->priv->fft1;
				_tmp12__length1 = self->priv->fft1_length1;
				_tmp13_ = i;
				_tmp14_ = _tmp12_[_tmp13_];
				_tmp15_ = _tmp14_.r;
				_tmp16_ = self->priv->fft1;
				_tmp16__length1 = self->priv->fft1_length1;
				_tmp17_ = i;
				_tmp18_ = _tmp16_[_tmp17_];
				_tmp19_ = _tmp18_.r;
				_tmp20_ = self->priv->fft1;
				_tmp20__length1 = self->priv->fft1_length1;
				_tmp21_ = i;
				_tmp22_ = _tmp20_[_tmp21_];
				_tmp23_ = _tmp22_.i;
				_tmp24_ = self->priv->fft1;
				_tmp24__length1 = self->priv->fft1_length1;
				_tmp25_ = i;
				_tmp26_ = _tmp24_[_tmp25_];
				_tmp27_ = _tmp26_.i;
				_tmp10_[_tmp11_] = (gfloat) ((_tmp15_ * _tmp19_) + (_tmp23_ * _tmp27_));
				_tmp28_ = _tmp10_[_tmp11_];
			}
		}
	}
	p = 0;
	threshold = 0.f;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp29_;
			_tmp29_ = TRUE;
			while (TRUE) {
				gboolean _tmp30_;
				gint _tmp32_;
				gfloat* _tmp33_;
				gint _tmp33__length1;
				gfloat* _tmp34_;
				gint _tmp34__length1;
				gint _tmp35_;
				gfloat _tmp36_;
				gfloat _tmp37_;
				_tmp30_ = _tmp29_;
				if (!_tmp30_) {
					gint _tmp31_;
					_tmp31_ = i;
					i = _tmp31_ + 1;
				}
				_tmp29_ = FALSE;
				_tmp32_ = i;
				_tmp33_ = self->spectrum;
				_tmp33__length1 = self->spectrum_length1;
				if (!(_tmp32_ < _tmp33__length1)) {
					break;
				}
				_tmp34_ = self->spectrum;
				_tmp34__length1 = self->spectrum_length1;
				_tmp35_ = i;
				_tmp36_ = _tmp34_[_tmp35_];
				_tmp37_ = threshold;
				if (_tmp36_ > _tmp37_) {
					gfloat* _tmp38_;
					gint _tmp38__length1;
					gint _tmp39_;
					gfloat _tmp40_;
					gint _tmp41_;
					_tmp38_ = self->spectrum;
					_tmp38__length1 = self->spectrum_length1;
					_tmp39_ = i;
					_tmp40_ = _tmp38_[_tmp39_];
					threshold = _tmp40_;
					_tmp41_ = i;
					p = _tmp41_;
				}
			}
		}
	}
	_tmp42_ = self->spectrum;
	_tmp42__length1 = self->spectrum_length1;
	_tmp43_ = p;
	_tmp44_ = _tmp42_[_tmp43_ - 1];
	_tmp45_ = self->spectrum;
	_tmp45__length1 = self->spectrum_length1;
	_tmp46_ = p;
	_tmp47_ = _tmp45_[_tmp46_];
	_tmp48_ = self->spectrum;
	_tmp48__length1 = self->spectrum_length1;
	_tmp49_ = p;
	_tmp50_ = _tmp48_[_tmp49_ + 1];
	_tmp51_ = pitch_estimation_parabolic (_tmp44_, _tmp47_, _tmp50_);
	ip = _tmp51_;
	_tmp52_ = p;
	_tmp53_ = self->priv->sample_rate;
	_tmp54_ = self->priv->fft1_length;
	result = (((gfloat) (_tmp52_ + ip)) * _tmp53_) / _tmp54_;
	return result;
}


static gfloat pitch_estimation_parabolic (gfloat y0, gfloat y1, gfloat y2) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	_tmp0_ = y0;
	_tmp1_ = y2;
	_tmp2_ = y0;
	_tmp3_ = y1;
	_tmp4_ = y2;
	result = (gfloat) ((0.5 * (_tmp0_ - _tmp1_)) / ((_tmp2_ - (2 * _tmp3_)) + _tmp4_));
	return result;
}


static void pitch_estimation_normalize_and_center_clip (PitchEstimation* self, gfloat* data, int data_length1) {
	gfloat max;
	gfloat _tmp19_;
	gfloat k;
	g_return_if_fail (self != NULL);
	max = 0.f;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				gfloat* _tmp4_;
				gint _tmp4__length1;
				gfloat* _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				gfloat _tmp7_;
				gfloat _tmp8_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = data;
				_tmp4__length1 = data_length1;
				if (!(_tmp3_ < _tmp4__length1)) {
					break;
				}
				_tmp5_ = data;
				_tmp5__length1 = data_length1;
				_tmp6_ = i;
				_tmp7_ = _tmp5_[_tmp6_];
				_tmp8_ = max;
				if (_tmp7_ > _tmp8_) {
					gfloat* _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					gfloat _tmp11_;
					_tmp9_ = data;
					_tmp9__length1 = data_length1;
					_tmp10_ = i;
					_tmp11_ = _tmp9_[_tmp10_];
					max = _tmp11_;
				} else {
					gfloat* _tmp12_;
					gint _tmp12__length1;
					gint _tmp13_;
					gfloat _tmp14_;
					gfloat _tmp15_;
					_tmp12_ = data;
					_tmp12__length1 = data_length1;
					_tmp13_ = i;
					_tmp14_ = _tmp12_[_tmp13_];
					_tmp15_ = max;
					if (_tmp14_ < (-_tmp15_)) {
						gfloat* _tmp16_;
						gint _tmp16__length1;
						gint _tmp17_;
						gfloat _tmp18_;
						_tmp16_ = data;
						_tmp16__length1 = data_length1;
						_tmp17_ = i;
						_tmp18_ = _tmp16_[_tmp17_];
						max = -_tmp18_;
					}
				}
			}
		}
	}
	_tmp19_ = max;
	k = 1.f / _tmp19_;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp20_;
			_tmp20_ = TRUE;
			while (TRUE) {
				gboolean _tmp21_;
				gint _tmp23_;
				gfloat* _tmp24_;
				gint _tmp24__length1;
				gfloat* _tmp25_;
				gint _tmp25__length1;
				gint _tmp26_;
				gfloat _tmp27_;
				gfloat _tmp28_;
				gfloat* _tmp29_;
				gint _tmp29__length1;
				gint _tmp30_;
				gfloat _tmp31_;
				gfloat _tmp32_;
				_tmp21_ = _tmp20_;
				if (!_tmp21_) {
					gint _tmp22_;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp20_ = FALSE;
				_tmp23_ = i;
				_tmp24_ = data;
				_tmp24__length1 = data_length1;
				if (!(_tmp23_ < _tmp24__length1)) {
					break;
				}
				_tmp25_ = data;
				_tmp25__length1 = data_length1;
				_tmp26_ = i;
				_tmp27_ = k;
				_tmp25_[_tmp26_] *= _tmp27_;
				_tmp28_ = _tmp25_[_tmp26_];
				_tmp29_ = data;
				_tmp29__length1 = data_length1;
				_tmp30_ = i;
				_tmp31_ = _tmp29_[_tmp30_];
				_tmp32_ = _tmp31_;
				if (((-0.5f) < _tmp32_) && (_tmp32_ < 0.5f)) {
					gfloat* _tmp33_;
					gint _tmp33__length1;
					gint _tmp34_;
					gfloat _tmp35_;
					_tmp33_ = data;
					_tmp33__length1 = data_length1;
					_tmp34_ = i;
					_tmp33_[_tmp34_] = (gfloat) 0;
					_tmp35_ = _tmp33_[_tmp34_];
				}
			}
		}
	}
}


static void value_pitch_estimation_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_pitch_estimation_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		pitch_estimation_unref (value->data[0].v_pointer);
	}
}


static void value_pitch_estimation_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = pitch_estimation_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_pitch_estimation_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_pitch_estimation_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PitchEstimation* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = pitch_estimation_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_pitch_estimation_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PitchEstimation** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = pitch_estimation_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_pitch_estimation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecPitchEstimation* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PITCH_ESTIMATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_pitch_estimation (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PITCH_ESTIMATION), NULL);
	return value->data[0].v_pointer;
}


void value_set_pitch_estimation (GValue* value, gpointer v_object) {
	PitchEstimation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PITCH_ESTIMATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PITCH_ESTIMATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		pitch_estimation_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		pitch_estimation_unref (old);
	}
}


void value_take_pitch_estimation (GValue* value, gpointer v_object) {
	PitchEstimation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PITCH_ESTIMATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PITCH_ESTIMATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		pitch_estimation_unref (old);
	}
}


static void pitch_estimation_class_init (PitchEstimationClass * klass) {
	pitch_estimation_parent_class = g_type_class_peek_parent (klass);
	PITCH_ESTIMATION_CLASS (klass)->finalize = pitch_estimation_finalize;
	g_type_class_add_private (klass, sizeof (PitchEstimationPrivate));
}


static void pitch_estimation_instance_init (PitchEstimation * self) {
	self->priv = PITCH_ESTIMATION_GET_PRIVATE (self);
	self->priv->pitch = 0.0f;
	self->ref_count = 1;
}


static void pitch_estimation_finalize (PitchEstimation* obj) {
	PitchEstimation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PITCH_ESTIMATION, PitchEstimation);
	self->priv->fft1 = (g_free (self->priv->fft1), NULL);
	self->priv->fft2 = (g_free (self->priv->fft2), NULL);
	kiss_fftr_free (self->priv->fft1_cfg);
	kiss_fftr_free (self->priv->fft2_cfg);
	kiss_fftr_free (self->priv->ffti_cfg);
	self->padded_data = (g_free (self->padded_data), NULL);
	self->autocorr_data = (g_free (self->autocorr_data), NULL);
	self->cepstrum = (g_free (self->cepstrum), NULL);
	self->spectrum = (g_free (self->spectrum), NULL);
}


GType pitch_estimation_get_type (void) {
	static volatile gsize pitch_estimation_type_id__volatile = 0;
	if (g_once_init_enter (&pitch_estimation_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_pitch_estimation_init, value_pitch_estimation_free_value, value_pitch_estimation_copy_value, value_pitch_estimation_peek_pointer, "p", value_pitch_estimation_collect_value, "p", value_pitch_estimation_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PitchEstimationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pitch_estimation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PitchEstimation), 0, (GInstanceInitFunc) pitch_estimation_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType pitch_estimation_type_id;
		pitch_estimation_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PitchEstimation", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&pitch_estimation_type_id__volatile, pitch_estimation_type_id);
	}
	return pitch_estimation_type_id__volatile;
}


gpointer pitch_estimation_ref (gpointer instance) {
	PitchEstimation* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void pitch_estimation_unref (gpointer instance) {
	PitchEstimation* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PITCH_ESTIMATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



