/* strobe.c generated by valac 0.18.1, the Vala compiler
 * generated from strobe.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include "pa_ringbuffer.h"
#include <gobject/gvaluecollector.h>


#define TYPE_STROBE (strobe_get_type ())
#define STROBE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STROBE, Strobe))
#define STROBE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STROBE, StrobeClass))
#define IS_STROBE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STROBE))
#define IS_STROBE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STROBE))
#define STROBE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STROBE, StrobeClass))

typedef struct _Strobe Strobe;
typedef struct _StrobeClass StrobeClass;
typedef struct _StrobePrivate StrobePrivate;

#define TYPE_BIQUAD (biquad_get_type ())
#define BIQUAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BIQUAD, Biquad))
#define BIQUAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BIQUAD, BiquadClass))
#define IS_BIQUAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BIQUAD))
#define IS_BIQUAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BIQUAD))
#define BIQUAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BIQUAD, BiquadClass))

typedef struct _Biquad Biquad;
typedef struct _BiquadClass BiquadClass;

#define TYPE_SRC (src_get_type ())
#define SRC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SRC, SRC))
#define SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SRC, SRCClass))
#define IS_SRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SRC))
#define IS_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SRC))
#define SRC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SRC, SRCClass))

typedef struct _SRC SRC;
typedef struct _SRCClass SRCClass;
#define _biquad_unref0(var) ((var == NULL) ? NULL : (var = (biquad_unref (var), NULL)))
#define _src_unref0(var) ((var == NULL) ? NULL : (var = (src_unref (var), NULL)))
typedef struct _ParamSpecStrobe ParamSpecStrobe;

struct _Strobe {
	GTypeInstance parent_instance;
	volatile int ref_count;
	StrobePrivate * priv;
};

struct _StrobeClass {
	GTypeClass parent_class;
	void (*finalize) (Strobe *self);
};

struct _StrobePrivate {
	gfloat freq;
	gfloat* filtered_buffer;
	gint filtered_buffer_length1;
	gint _filtered_buffer_size_;
	gfloat* resampled_buffer;
	gint resampled_buffer_length1;
	gint _resampled_buffer_size_;
	Biquad* bandpass;
	gdouble* bandpass_coeffs;
	gint bandpass_coeffs_length1;
	gint _bandpass_coeffs_size_;
	SRC* src;
	PaUtilRingBuffer ringbuffer;
	gfloat* _ringbuffer;
	gint _ringbuffer_length1;
	gint __ringbuffer_size_;
	gint sample_rate;
	gint samples_per_period;
};

struct _ParamSpecStrobe {
	GParamSpec parent_instance;
};


static gpointer strobe_parent_class = NULL;

gpointer strobe_ref (gpointer instance);
void strobe_unref (gpointer instance);
GParamSpec* param_spec_strobe (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_strobe (GValue* value, gpointer v_object);
void value_take_strobe (GValue* value, gpointer v_object);
gpointer value_get_strobe (const GValue* value);
GType strobe_get_type (void) G_GNUC_CONST;
gpointer biquad_ref (gpointer instance);
void biquad_unref (gpointer instance);
GParamSpec* param_spec_biquad (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_biquad (GValue* value, gpointer v_object);
void value_take_biquad (GValue* value, gpointer v_object);
gpointer value_get_biquad (const GValue* value);
GType biquad_get_type (void) G_GNUC_CONST;
gpointer src_ref (gpointer instance);
void src_unref (gpointer instance);
GParamSpec* param_spec_src (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_src (GValue* value, gpointer v_object);
void value_take_src (GValue* value, gpointer v_object);
gpointer value_get_src (const GValue* value);
GType src_get_type (void) G_GNUC_CONST;
#define STROBE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_STROBE, StrobePrivate))
enum  {
	STROBE_DUMMY_PROPERTY
};
Strobe* strobe_new (gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period);
Strobe* strobe_construct (GType object_type, gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period);
Biquad* biquad_new (gint sectionCount);
Biquad* biquad_construct (GType object_type, gint sectionCount);
SRC* src_new (gdouble out_rate, gdouble in_rate);
SRC* src_construct (GType object_type, gdouble out_rate, gdouble in_rate);
void strobe_read (Strobe* self, gfloat** output, int* output_length1);
void strobe_set_target_freq (Strobe* self, gfloat freq);
void src_set_ratio (SRC* self, gdouble out_rate, gdouble in_rate);
void src_reset (SRC* self);
void biquad_reset (Biquad* self);
gdouble* biquad_bandpass (gdouble cutoff, gdouble samplerate, gdouble Q, int* result_length1);
void strobe_process_signal (Strobe* self, gfloat* input, int input_length1);
void biquad_filter (Biquad* self, gdouble* biquad, int biquad_length1, gfloat* input, int input_length1, gfloat* output, int output_length1);
gint src_cubic_convert (SRC* self, gfloat* in, int in_length1, gfloat* out, int out_length1);
static void strobe_finalize (Strobe* obj);


Strobe* strobe_construct (GType object_type, gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period) {
	Strobe* self = NULL;
	gint _tmp0_;
	gint _tmp1_;
	Biquad* _tmp2_;
	SRC* _tmp3_;
	gint _tmp4_;
	gfloat* _tmp5_ = NULL;
	gint _tmp6_;
	gfloat* _tmp7_ = NULL;
	gfloat* _tmp8_ = NULL;
	gfloat* _tmp9_;
	gint _tmp9__length1;
	gfloat* _tmp10_;
	gint _tmp10__length1;
	self = (Strobe*) g_type_create_instance (object_type);
	_tmp0_ = sample_rate;
	self->priv->sample_rate = _tmp0_;
	_tmp1_ = samples_per_period;
	self->priv->samples_per_period = _tmp1_;
	_tmp2_ = biquad_new (3);
	_biquad_unref0 (self->priv->bandpass);
	self->priv->bandpass = _tmp2_;
	_tmp3_ = src_new ((gdouble) 1, (gdouble) 1);
	_src_unref0 (self->priv->src);
	self->priv->src = _tmp3_;
	_tmp4_ = buffer_length;
	_tmp5_ = g_new0 (gfloat, _tmp4_);
	self->priv->filtered_buffer = (g_free (self->priv->filtered_buffer), NULL);
	self->priv->filtered_buffer = _tmp5_;
	self->priv->filtered_buffer_length1 = _tmp4_;
	self->priv->_filtered_buffer_size_ = self->priv->filtered_buffer_length1;
	_tmp6_ = resampled_buffer_length;
	_tmp7_ = g_new0 (gfloat, _tmp6_);
	self->priv->resampled_buffer = (g_free (self->priv->resampled_buffer), NULL);
	self->priv->resampled_buffer = _tmp7_;
	self->priv->resampled_buffer_length1 = _tmp6_;
	self->priv->_resampled_buffer_size_ = self->priv->resampled_buffer_length1;
	_tmp8_ = g_new0 (gfloat, 65536);
	self->priv->_ringbuffer = (g_free (self->priv->_ringbuffer), NULL);
	self->priv->_ringbuffer = _tmp8_;
	self->priv->_ringbuffer_length1 = 65536;
	self->priv->__ringbuffer_size_ = self->priv->_ringbuffer_length1;
	_tmp9_ = self->priv->_ringbuffer;
	_tmp9__length1 = self->priv->_ringbuffer_length1;
	_tmp10_ = self->priv->_ringbuffer;
	_tmp10__length1 = self->priv->_ringbuffer_length1;
	PaUtil_InitializeRingBuffer (&self->priv->ringbuffer, (ring_buffer_size_t) sizeof (gfloat), (ring_buffer_size_t) _tmp9__length1, _tmp10_);
	return self;
}


Strobe* strobe_new (gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period) {
	return strobe_construct (TYPE_STROBE, buffer_length, resampled_buffer_length, sample_rate, samples_per_period);
}


/**
   * Read the newest data from the ring buffer
   */
void strobe_read (Strobe* self, gfloat** output, int* output_length1) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		ring_buffer_size_t _tmp0_ = 0L;
		gfloat* _tmp1_;
		gint _tmp1__length1;
		gfloat* _tmp2_;
		gint _tmp2__length1;
		gfloat* _tmp3_;
		gint _tmp3__length1;
		_tmp0_ = PaUtil_GetRingBufferReadAvailable (&self->priv->ringbuffer);
		_tmp1_ = *output;
		_tmp1__length1 = *output_length1;
		if (!(_tmp0_ >= ((ring_buffer_size_t) _tmp1__length1))) {
			break;
		}
		_tmp2_ = *output;
		_tmp2__length1 = *output_length1;
		_tmp3_ = *output;
		_tmp3__length1 = *output_length1;
		PaUtil_ReadRingBuffer (&self->priv->ringbuffer, _tmp2_, (ring_buffer_size_t) _tmp3__length1);
	}
}


/**
   * Set the filter band and the sample rate to a multiple of the target frequency
   */
void strobe_set_target_freq (Strobe* self, gfloat freq) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = freq;
	_tmp1_ = self->priv->freq;
	if (_tmp0_ != _tmp1_) {
		gfloat _tmp2_;
		SRC* _tmp3_;
		gfloat _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		SRC* _tmp7_;
		Biquad* _tmp8_;
		gfloat _tmp9_;
		gint _tmp10_;
		gint _tmp11_ = 0;
		gdouble* _tmp12_ = NULL;
		_tmp2_ = freq;
		self->priv->freq = _tmp2_;
		_tmp3_ = self->priv->src;
		_tmp4_ = freq;
		_tmp5_ = self->priv->samples_per_period;
		_tmp6_ = self->priv->sample_rate;
		src_set_ratio (_tmp3_, (gdouble) (_tmp4_ * _tmp5_), (gdouble) _tmp6_);
		_tmp7_ = self->priv->src;
		src_reset (_tmp7_);
		_tmp8_ = self->priv->bandpass;
		biquad_reset (_tmp8_);
		_tmp9_ = freq;
		_tmp10_ = self->priv->sample_rate;
		_tmp12_ = biquad_bandpass ((gdouble) _tmp9_, (gdouble) _tmp10_, (gdouble) 10, &_tmp11_);
		self->priv->bandpass_coeffs = (g_free (self->priv->bandpass_coeffs), NULL);
		self->priv->bandpass_coeffs = _tmp12_;
		self->priv->bandpass_coeffs_length1 = _tmp11_;
		self->priv->_bandpass_coeffs_size_ = self->priv->bandpass_coeffs_length1;
	}
}


/**
   * Process the audio input and write into the ring buffer
   */
void strobe_process_signal (Strobe* self, gfloat* input, int input_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* fb;
	gint fb_length1;
	gint _fb_size_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_;
	Biquad* _tmp3_;
	gdouble* _tmp4_;
	gint _tmp4__length1;
	gfloat* _tmp5_;
	gint _tmp5__length1;
	SRC* _tmp6_;
	gfloat* _tmp7_;
	gint _tmp7__length1;
	gint _tmp8_ = 0;
	gint count;
	gfloat* _tmp9_;
	gint _tmp9__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->filtered_buffer;
	_tmp0__length1 = self->priv->filtered_buffer_length1;
	fb = _tmp0_;
	fb_length1 = _tmp0__length1;
	_fb_size_ = fb_length1;
	_tmp1_ = input;
	_tmp1__length1 = input_length1;
	fb_length1 = _tmp1__length1;
	_tmp2_ = fb_length1;
	_tmp3_ = self->priv->bandpass;
	_tmp4_ = self->priv->bandpass_coeffs;
	_tmp4__length1 = self->priv->bandpass_coeffs_length1;
	_tmp5_ = input;
	_tmp5__length1 = input_length1;
	biquad_filter (_tmp3_, _tmp4_, _tmp4__length1, _tmp5_, _tmp5__length1, fb, fb_length1);
	_tmp6_ = self->priv->src;
	_tmp7_ = self->priv->resampled_buffer;
	_tmp7__length1 = self->priv->resampled_buffer_length1;
	_tmp8_ = src_cubic_convert (_tmp6_, fb, fb_length1, _tmp7_, _tmp7__length1);
	count = _tmp8_;
	_tmp9_ = self->priv->resampled_buffer;
	_tmp9__length1 = self->priv->resampled_buffer_length1;
	PaUtil_WriteRingBuffer (&self->priv->ringbuffer, _tmp9_, (ring_buffer_size_t) count);
}


static void value_strobe_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_strobe_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		strobe_unref (value->data[0].v_pointer);
	}
}


static void value_strobe_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = strobe_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_strobe_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_strobe_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Strobe* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = strobe_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_strobe_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Strobe** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = strobe_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_strobe (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecStrobe* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_STROBE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_strobe (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STROBE), NULL);
	return value->data[0].v_pointer;
}


void value_set_strobe (GValue* value, gpointer v_object) {
	Strobe* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STROBE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_STROBE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		strobe_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		strobe_unref (old);
	}
}


void value_take_strobe (GValue* value, gpointer v_object) {
	Strobe* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STROBE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_STROBE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		strobe_unref (old);
	}
}


static void strobe_class_init (StrobeClass * klass) {
	strobe_parent_class = g_type_class_peek_parent (klass);
	STROBE_CLASS (klass)->finalize = strobe_finalize;
	g_type_class_add_private (klass, sizeof (StrobePrivate));
}


static void strobe_instance_init (Strobe * self) {
	self->priv = STROBE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void strobe_finalize (Strobe* obj) {
	Strobe * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_STROBE, Strobe);
	self->priv->filtered_buffer = (g_free (self->priv->filtered_buffer), NULL);
	self->priv->resampled_buffer = (g_free (self->priv->resampled_buffer), NULL);
	_biquad_unref0 (self->priv->bandpass);
	self->priv->bandpass_coeffs = (g_free (self->priv->bandpass_coeffs), NULL);
	_src_unref0 (self->priv->src);
	 (&self->priv->ringbuffer);
	self->priv->_ringbuffer = (g_free (self->priv->_ringbuffer), NULL);
}


GType strobe_get_type (void) {
	static volatile gsize strobe_type_id__volatile = 0;
	if (g_once_init_enter (&strobe_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_strobe_init, value_strobe_free_value, value_strobe_copy_value, value_strobe_peek_pointer, "p", value_strobe_collect_value, "p", value_strobe_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (StrobeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) strobe_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Strobe), 0, (GInstanceInitFunc) strobe_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType strobe_type_id;
		strobe_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Strobe", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&strobe_type_id__volatile, strobe_type_id);
	}
	return strobe_type_id__volatile;
}


gpointer strobe_ref (gpointer instance) {
	Strobe* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void strobe_unref (gpointer instance) {
	Strobe* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		STROBE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



