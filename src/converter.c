/* converter.c generated by valac 0.18.1, the Vala compiler
 * generated from converter.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include "pa_ringbuffer.h"
#include <gobject/gvaluecollector.h>


#define TYPE_CONVERTER (converter_get_type ())
#define CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERTER, Converter))
#define CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERTER, ConverterClass))
#define IS_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERTER))
#define IS_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERTER))
#define CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERTER, ConverterClass))

typedef struct _Converter Converter;
typedef struct _ConverterClass ConverterClass;
typedef struct _ConverterPrivate ConverterPrivate;

#define TYPE_SRC (src_get_type ())
#define SRC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SRC, SRC))
#define SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SRC, SRCClass))
#define IS_SRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SRC))
#define IS_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SRC))
#define SRC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SRC, SRCClass))

typedef struct _SRC SRC;
typedef struct _SRCClass SRCClass;
#define _src_unref0(var) ((var == NULL) ? NULL : (var = (src_unref (var), NULL)))
typedef struct _ParamSpecConverter ParamSpecConverter;

struct _Converter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ConverterPrivate * priv;
};

struct _ConverterClass {
	GTypeClass parent_class;
	void (*finalize) (Converter *self);
};

struct _ConverterPrivate {
	gfloat* filtered_buffer;
	gint filtered_buffer_length1;
	gint _filtered_buffer_size_;
	gfloat* resampled_buffer;
	gint resampled_buffer_length1;
	gint _resampled_buffer_size_;
	PaUtilRingBuffer ringbuffer;
	gfloat* _ringbuffer;
	gint _ringbuffer_length1;
	gint __ringbuffer_size_;
	SRC* src;
};

struct _ParamSpecConverter {
	GParamSpec parent_instance;
};


static gpointer converter_parent_class = NULL;

gpointer converter_ref (gpointer instance);
void converter_unref (gpointer instance);
GParamSpec* param_spec_converter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_converter (GValue* value, gpointer v_object);
void value_take_converter (GValue* value, gpointer v_object);
gpointer value_get_converter (const GValue* value);
GType converter_get_type (void) G_GNUC_CONST;
gpointer src_ref (gpointer instance);
void src_unref (gpointer instance);
GParamSpec* param_spec_src (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_src (GValue* value, gpointer v_object);
void value_take_src (GValue* value, gpointer v_object);
gpointer value_get_src (const GValue* value);
GType src_get_type (void) G_GNUC_CONST;
#define CONVERTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CONVERTER, ConverterPrivate))
enum  {
	CONVERTER_DUMMY_PROPERTY
};
Converter* converter_new (gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate);
Converter* converter_construct (GType object_type, gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate);
SRC* src_new (gdouble out_rate, gdouble in_rate);
SRC* src_construct (GType object_type, gdouble out_rate, gdouble in_rate);
void converter_read (Converter* self, gfloat** output, int* output_length1);
void converter_process_signal (Converter* self, gfloat* input, int input_length1);
static void converter_finalize (Converter* obj);


Converter* converter_construct (GType object_type, gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate) {
	Converter* self = NULL;
	gint _tmp0_;
	gint _tmp1_;
	SRC* _tmp2_;
	gint _tmp3_;
	gfloat* _tmp4_ = NULL;
	gint _tmp5_;
	gfloat* _tmp6_ = NULL;
	gfloat* _tmp7_ = NULL;
	gfloat* _tmp8_;
	gint _tmp8__length1;
	gfloat* _tmp9_;
	gint _tmp9__length1;
	self = (Converter*) g_type_create_instance (object_type);
	_tmp0_ = fft_sample_rate;
	_tmp1_ = sample_rate;
	_tmp2_ = src_new ((gdouble) _tmp0_, (gdouble) _tmp1_);
	_src_unref0 (self->priv->src);
	self->priv->src = _tmp2_;
	_tmp3_ = buffer_length;
	_tmp4_ = g_new0 (gfloat, _tmp3_);
	self->priv->filtered_buffer = (g_free (self->priv->filtered_buffer), NULL);
	self->priv->filtered_buffer = _tmp4_;
	self->priv->filtered_buffer_length1 = _tmp3_;
	self->priv->_filtered_buffer_size_ = self->priv->filtered_buffer_length1;
	_tmp5_ = buffer_length;
	_tmp6_ = g_new0 (gfloat, _tmp5_);
	self->priv->resampled_buffer = (g_free (self->priv->resampled_buffer), NULL);
	self->priv->resampled_buffer = _tmp6_;
	self->priv->resampled_buffer_length1 = _tmp5_;
	self->priv->_resampled_buffer_size_ = self->priv->resampled_buffer_length1;
	_tmp7_ = g_new0 (gfloat, 32768);
	self->priv->_ringbuffer = (g_free (self->priv->_ringbuffer), NULL);
	self->priv->_ringbuffer = _tmp7_;
	self->priv->_ringbuffer_length1 = 32768;
	self->priv->__ringbuffer_size_ = self->priv->_ringbuffer_length1;
	_tmp8_ = self->priv->_ringbuffer;
	_tmp8__length1 = self->priv->_ringbuffer_length1;
	_tmp9_ = self->priv->_ringbuffer;
	_tmp9__length1 = self->priv->_ringbuffer_length1;
	PaUtil_InitializeRingBuffer (&self->priv->ringbuffer, (ring_buffer_size_t) sizeof (gfloat), (ring_buffer_size_t) _tmp8__length1, _tmp9_);
	return self;
}


Converter* converter_new (gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate) {
	return converter_construct (TYPE_CONVERTER, buffer_length, fft_sample_rate, lowpass_cutoff, highpass_cutoff, sample_rate);
}


/**
   * Read the newest data from the ring buffer
   */
void converter_read (Converter* self, gfloat** output, int* output_length1) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		ring_buffer_size_t _tmp0_ = 0L;
		gfloat* _tmp1_;
		gint _tmp1__length1;
		gfloat* _tmp2_;
		gint _tmp2__length1;
		gfloat* _tmp3_;
		gint _tmp3__length1;
		_tmp0_ = PaUtil_GetRingBufferReadAvailable (&self->priv->ringbuffer);
		_tmp1_ = *output;
		_tmp1__length1 = *output_length1;
		if (!(_tmp0_ >= ((ring_buffer_size_t) _tmp1__length1))) {
			break;
		}
		_tmp2_ = *output;
		_tmp2__length1 = *output_length1;
		_tmp3_ = *output;
		_tmp3__length1 = *output_length1;
		PaUtil_ReadRingBuffer (&self->priv->ringbuffer, _tmp2_, (ring_buffer_size_t) _tmp3__length1);
	}
}


/**
   * Process the audio input and write into the ring buffer
   */
void converter_process_signal (Converter* self, gfloat* input, int input_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* fb;
	gint fb_length1;
	gint _fb_size_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	gfloat* _tmp4_;
	gint _tmp4__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->filtered_buffer;
	_tmp0__length1 = self->priv->filtered_buffer_length1;
	fb = _tmp0_;
	fb_length1 = _tmp0__length1;
	_fb_size_ = fb_length1;
	_tmp1_ = input;
	_tmp1__length1 = input_length1;
	fb_length1 = _tmp1__length1;
	_tmp2_ = fb_length1;
	_tmp3_ = input;
	_tmp3__length1 = input_length1;
	_tmp4_ = input;
	_tmp4__length1 = input_length1;
	PaUtil_WriteRingBuffer (&self->priv->ringbuffer, _tmp3_, (ring_buffer_size_t) _tmp4__length1);
}


static void value_converter_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_converter_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		converter_unref (value->data[0].v_pointer);
	}
}


static void value_converter_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = converter_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_converter_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_converter_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Converter* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = converter_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_converter_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Converter** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = converter_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_converter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecConverter* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_CONVERTER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_converter (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONVERTER), NULL);
	return value->data[0].v_pointer;
}


void value_set_converter (GValue* value, gpointer v_object) {
	Converter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONVERTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CONVERTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		converter_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		converter_unref (old);
	}
}


void value_take_converter (GValue* value, gpointer v_object) {
	Converter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONVERTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CONVERTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		converter_unref (old);
	}
}


static void converter_class_init (ConverterClass * klass) {
	converter_parent_class = g_type_class_peek_parent (klass);
	CONVERTER_CLASS (klass)->finalize = converter_finalize;
	g_type_class_add_private (klass, sizeof (ConverterPrivate));
}


static void converter_instance_init (Converter * self) {
	self->priv = CONVERTER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void converter_finalize (Converter* obj) {
	Converter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CONVERTER, Converter);
	self->priv->filtered_buffer = (g_free (self->priv->filtered_buffer), NULL);
	self->priv->resampled_buffer = (g_free (self->priv->resampled_buffer), NULL);
	 (&self->priv->ringbuffer);
	self->priv->_ringbuffer = (g_free (self->priv->_ringbuffer), NULL);
	_src_unref0 (self->priv->src);
}


GType converter_get_type (void) {
	static volatile gsize converter_type_id__volatile = 0;
	if (g_once_init_enter (&converter_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_converter_init, value_converter_free_value, value_converter_copy_value, value_converter_peek_pointer, "p", value_converter_collect_value, "p", value_converter_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ConverterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) converter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Converter), 0, (GInstanceInitFunc) converter_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType converter_type_id;
		converter_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Converter", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&converter_type_id__volatile, converter_type_id);
	}
	return converter_type_id__volatile;
}


gpointer converter_ref (gpointer instance) {
	Converter* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void converter_unref (gpointer instance) {
	Converter* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CONVERTER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



