/* gl_cairo_window.c generated by valac 0.18.1, the Vala compiler
 * generated from gl_cairo_window.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include "OpenGL/gl.h"
#include "GL/glfw.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GL_CAIRO_WINDOW (gl_cairo_window_get_type ())
#define GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindow))
#define GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))
#define IS_GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GL_CAIRO_WINDOW))
#define IS_GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GL_CAIRO_WINDOW))
#define GL_CAIRO_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))

typedef struct _GLCairoWindow GLCairoWindow;
typedef struct _GLCairoWindowClass GLCairoWindowClass;
typedef struct _GLCairoWindowPrivate GLCairoWindowPrivate;
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
typedef struct _ParamSpecGLCairoWindow ParamSpecGLCairoWindow;

struct _GLCairoWindow {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GLCairoWindowPrivate * priv;
	cairo_surface_t* surface;
	cairo_t* context;
	guchar* surface_data;
	gint surface_data_length1;
	gboolean quit;
	gint window_width;
	gint window_height;
	GLuint* textures;
	gint textures_length1;
};

struct _GLCairoWindowClass {
	GTypeClass parent_class;
	void (*finalize) (GLCairoWindow *self);
};

struct _ParamSpecGLCairoWindow {
	GParamSpec parent_instance;
};


static gpointer gl_cairo_window_parent_class = NULL;

gpointer gl_cairo_window_ref (gpointer instance);
void gl_cairo_window_unref (gpointer instance);
GParamSpec* param_spec_gl_cairo_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gl_cairo_window (GValue* value, gpointer v_object);
void value_take_gl_cairo_window (GValue* value, gpointer v_object);
gpointer value_get_gl_cairo_window (const GValue* value);
GType gl_cairo_window_get_type (void) G_GNUC_CONST;
enum  {
	GL_CAIRO_WINDOW_DUMMY_PROPERTY
};
GLCairoWindow* gl_cairo_window_new (const gchar* title, gint width, gint height);
GLCairoWindow* gl_cairo_window_construct (GType object_type, const gchar* title, gint width, gint height);
void gl_cairo_window_init_video (GLCairoWindow* self, gint width, gint height);
void gl_cairo_window_flush (GLCairoWindow* self);
void gl_cairo_window_process_events (GLCairoWindow* self);
gboolean gl_cairo_window_get_key (GLCairoWindow* self, gint key);
static void gl_cairo_window_finalize (GLCairoWindow* obj);


GLCairoWindow* gl_cairo_window_construct (GType object_type, const gchar* title, gint width, gint height) {
	GLCairoWindow* self = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp2_;
	gint _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	g_return_val_if_fail (title != NULL, NULL);
	self = (GLCairoWindow*) g_type_create_instance (object_type);
	_tmp0_ = glfwInit ();
	if (!_tmp0_) {
		FILE* _tmp1_;
		_tmp1_ = stderr;
		fprintf (_tmp1_, "Could not create an OpenGL window.\n");
		exit (EXIT_FAILURE);
	}
	glfwOpenWindowHint (GLFW_WINDOW_NO_RESIZE, GL_TRUE);
	_tmp2_ = width;
	_tmp3_ = height;
	_tmp4_ = glfwOpenWindow (_tmp2_, _tmp3_, 8, 8, 8, 8, 0, 0, GLFW_WINDOW);
	if (!_tmp4_) {
		FILE* _tmp5_;
		glfwTerminate ();
		_tmp5_ = stderr;
		fprintf (_tmp5_, "Could not create an OpenGL window.\n");
		exit (EXIT_FAILURE);
	}
	_tmp6_ = title;
	glfwSetWindowTitle (_tmp6_);
	_tmp7_ = width;
	_tmp8_ = height;
	gl_cairo_window_init_video (self, _tmp7_, _tmp8_);
	return self;
}


GLCairoWindow* gl_cairo_window_new (const gchar* title, gint width, gint height) {
	return gl_cairo_window_construct (TYPE_GL_CAIRO_WINDOW, title, width, height);
}


void gl_cairo_window_init_video (GLCairoWindow* self, gint width, gint height) {
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	cairo_surface_t* _tmp4_;
	cairo_surface_t* _tmp5_;
	guchar* _tmp6_ = NULL;
	cairo_surface_t* _tmp7_;
	cairo_t* _tmp8_;
	GLuint* _tmp9_;
	gint _tmp9__length1;
	GLuint* _tmp10_;
	gint _tmp10__length1;
	GLuint _tmp11_;
	gint _tmp12_;
	gint _tmp13_;
	g_return_if_fail (self != NULL);
	_tmp0_ = width;
	self->window_width = _tmp0_;
	_tmp1_ = height;
	self->window_height = _tmp1_;
	_tmp2_ = width;
	_tmp3_ = height;
	_tmp4_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp2_, _tmp3_);
	_cairo_surface_destroy0 (self->surface);
	self->surface = _tmp4_;
	_tmp5_ = self->surface;
	_tmp6_ = cairo_image_surface_get_data (_tmp5_);
	self->surface_data = _tmp6_;
	self->surface_data_length1 = -1;
	_tmp7_ = self->surface;
	_tmp8_ = cairo_create (_tmp7_);
	_cairo_destroy0 (self->context);
	self->context = _tmp8_;
	glDisable ((GLenum) GL_BLEND);
	glDisable ((GLenum) GL_DEPTH_TEST);
	glDisable ((GLenum) GL_STENCIL_TEST);
	glEnable ((GLenum) GL_TEXTURE_2D);
	_tmp9_ = self->textures;
	_tmp9__length1 = self->textures_length1;
	glGenTextures ((GLsizei) 1, _tmp9_);
	_tmp10_ = self->textures;
	_tmp10__length1 = self->textures_length1;
	_tmp11_ = _tmp10_[0];
	glBindTexture ((GLenum) GL_TEXTURE_2D, _tmp11_);
	glTexParameteri ((GLenum) GL_TEXTURE_2D, (GLenum) GL_TEXTURE_MAG_FILTER, (GLint) GL_NEAREST);
	glTexParameteri ((GLenum) GL_TEXTURE_2D, (GLenum) GL_TEXTURE_MIN_FILTER, (GLint) GL_NEAREST);
	_tmp12_ = width;
	_tmp13_ = height;
	glTexImage2D ((GLenum) GL_TEXTURE_2D, (GLint) 0, (GLint) GL_RGBA, (GLsizei) _tmp12_, (GLsizei) _tmp13_, (GLint) 0, (GLenum) GL_BGRA, (GLenum) GL_UNSIGNED_BYTE, NULL);
}


void gl_cairo_window_flush (GLCairoWindow* self) {
	gint _tmp0_;
	gint _tmp1_;
	guchar* _tmp2_;
	gint _tmp2__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->window_width;
	_tmp1_ = self->window_height;
	_tmp2_ = self->surface_data;
	_tmp2__length1 = self->surface_data_length1;
	glTexSubImage2D ((GLenum) GL_TEXTURE_2D, (GLint) 0, (GLint) 0, (GLint) 0, (GLsizei) _tmp0_, (GLsizei) _tmp1_, (GLenum) GL_BGRA, (GLenum) GL_UNSIGNED_BYTE, (GLvoid*) _tmp2_);
	glBegin ((GLenum) GL_QUADS);
	glTexCoord2f ((GLfloat) 0.f, (GLfloat) 1.f);
	glVertex2f ((GLfloat) (-1.f), (GLfloat) (-1.f));
	glTexCoord2f ((GLfloat) 1.f, (GLfloat) 1.f);
	glVertex2f ((GLfloat) 1.f, (GLfloat) (-1.f));
	glTexCoord2f ((GLfloat) 1.f, (GLfloat) 0.f);
	glVertex2f ((GLfloat) 1.f, (GLfloat) 1.f);
	glTexCoord2f ((GLfloat) 0.f, (GLfloat) 0.f);
	glVertex2f ((GLfloat) (-1.f), (GLfloat) 1.f);
	glEnd ();
	glDrawBuffer ((GLenum) GL_BACK);
	glfwSwapBuffers ();
}


void gl_cairo_window_process_events (GLCairoWindow* self) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	gl_cairo_window_flush (self);
	_tmp0_ = glfwGetWindowParam (GLFW_OPENED);
	if (!((gboolean) _tmp0_)) {
		self->quit = TRUE;
	}
}


gboolean gl_cairo_window_get_key (GLCairoWindow* self, gint key) {
	gboolean result = FALSE;
	gint _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = key;
	_tmp1_ = glfwGetKey (_tmp0_);
	result = _tmp1_;
	return result;
}


static void value_gl_cairo_window_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_gl_cairo_window_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gl_cairo_window_unref (value->data[0].v_pointer);
	}
}


static void value_gl_cairo_window_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gl_cairo_window_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_gl_cairo_window_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_gl_cairo_window_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GLCairoWindow* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gl_cairo_window_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_gl_cairo_window_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GLCairoWindow** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gl_cairo_window_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_gl_cairo_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGLCairoWindow* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GL_CAIRO_WINDOW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_gl_cairo_window (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GL_CAIRO_WINDOW), NULL);
	return value->data[0].v_pointer;
}


void value_set_gl_cairo_window (GValue* value, gpointer v_object) {
	GLCairoWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GL_CAIRO_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GL_CAIRO_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gl_cairo_window_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gl_cairo_window_unref (old);
	}
}


void value_take_gl_cairo_window (GValue* value, gpointer v_object) {
	GLCairoWindow* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GL_CAIRO_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GL_CAIRO_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gl_cairo_window_unref (old);
	}
}


static void gl_cairo_window_class_init (GLCairoWindowClass * klass) {
	gl_cairo_window_parent_class = g_type_class_peek_parent (klass);
	GL_CAIRO_WINDOW_CLASS (klass)->finalize = gl_cairo_window_finalize;
}


static void gl_cairo_window_instance_init (GLCairoWindow * self) {
	GLuint* _tmp0_ = NULL;
	_tmp0_ = g_new0 (GLuint, 1);
	self->textures = _tmp0_;
	self->textures_length1 = 1;
	self->ref_count = 1;
}


static void gl_cairo_window_finalize (GLCairoWindow* obj) {
	GLCairoWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GL_CAIRO_WINDOW, GLCairoWindow);
	glfwTerminate ();
	_cairo_surface_destroy0 (self->surface);
	_cairo_destroy0 (self->context);
	self->textures = (g_free (self->textures), NULL);
}


GType gl_cairo_window_get_type (void) {
	static volatile gsize gl_cairo_window_type_id__volatile = 0;
	if (g_once_init_enter (&gl_cairo_window_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_gl_cairo_window_init, value_gl_cairo_window_free_value, value_gl_cairo_window_copy_value, value_gl_cairo_window_peek_pointer, "p", value_gl_cairo_window_collect_value, "p", value_gl_cairo_window_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GLCairoWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gl_cairo_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GLCairoWindow), 0, (GInstanceInitFunc) gl_cairo_window_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gl_cairo_window_type_id;
		gl_cairo_window_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GLCairoWindow", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gl_cairo_window_type_id__volatile, gl_cairo_window_type_id);
	}
	return gl_cairo_window_type_id__volatile;
}


gpointer gl_cairo_window_ref (gpointer instance) {
	GLCairoWindow* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gl_cairo_window_unref (gpointer instance) {
	GLCairoWindow* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GL_CAIRO_WINDOW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



