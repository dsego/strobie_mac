/* display.c generated by valac 0.18.1, the Vala compiler
 * generated from display.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include "OpenGL/gl.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <float.h>
#include <math.h>


#define TYPE_GL_CAIRO_WINDOW (gl_cairo_window_get_type ())
#define GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindow))
#define GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))
#define IS_GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GL_CAIRO_WINDOW))
#define IS_GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GL_CAIRO_WINDOW))
#define GL_CAIRO_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))

typedef struct _GLCairoWindow GLCairoWindow;
typedef struct _GLCairoWindowClass GLCairoWindowClass;
typedef struct _GLCairoWindowPrivate GLCairoWindowPrivate;

#define TYPE_DISPLAY (display_get_type ())
#define DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DISPLAY, Display))
#define DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DISPLAY, DisplayClass))
#define IS_DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DISPLAY))
#define IS_DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DISPLAY))
#define DISPLAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DISPLAY, DisplayClass))

typedef struct _Display Display;
typedef struct _DisplayClass DisplayClass;
typedef struct _DisplayPrivate DisplayPrivate;
#define _cairo_font_face_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_font_face_destroy (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define DISPLAY_TYPE_STROBE_SIGNAL (display_strobe_signal_get_type ())
typedef struct _DisplayStrobeSignal DisplayStrobeSignal;

#define TYPE_RGB (rgb_get_type ())
typedef struct _RGB RGB;
#define _cairo_pattern_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_pattern_destroy (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _GLCairoWindow {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GLCairoWindowPrivate * priv;
	cairo_surface_t* surface;
	cairo_t* context;
	guchar* surface_data;
	gint surface_data_length1;
	gboolean quit;
	gint window_width;
	gint window_height;
	GLuint* textures;
	gint textures_length1;
};

struct _GLCairoWindowClass {
	GTypeClass parent_class;
	void (*finalize) (GLCairoWindow *self);
};

struct _Display {
	GLCairoWindow parent_instance;
	DisplayPrivate * priv;
};

struct _DisplayClass {
	GLCairoWindowClass parent_class;
};

struct _DisplayStrobeSignal {
	gchar* name;
	gfloat* data;
	gint data_length1;
};

struct _RGB {
	gfloat r;
	gfloat g;
	gfloat b;
};


static gpointer display_parent_class = NULL;

gpointer gl_cairo_window_ref (gpointer instance);
void gl_cairo_window_unref (gpointer instance);
GParamSpec* param_spec_gl_cairo_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gl_cairo_window (GValue* value, gpointer v_object);
void value_take_gl_cairo_window (GValue* value, gpointer v_object);
gpointer value_get_gl_cairo_window (const GValue* value);
GType gl_cairo_window_get_type (void) G_GNUC_CONST;
GType display_get_type (void) G_GNUC_CONST;
enum  {
	DISPLAY_DUMMY_PROPERTY
};
Display* display_new (const gchar* title, gint width, gint height);
Display* display_construct (GType object_type, const gchar* title, gint width, gint height);
GLCairoWindow* gl_cairo_window_new (const gchar* title, gint width, gint height);
GLCairoWindow* gl_cairo_window_construct (GType object_type, const gchar* title, gint width, gint height);
void display_set_font (Display* self);
cairo_font_face_t* font_loader_load (const gchar* path, GError** error);
void display_init_text_layouts (Display* self);
void display_draw_strobe (Display* self, gfloat* data, int data_length1);
GType display_strobe_signal_get_type (void) G_GNUC_CONST;
DisplayStrobeSignal* display_strobe_signal_dup (const DisplayStrobeSignal* self);
void display_strobe_signal_free (DisplayStrobeSignal* self);
void display_strobe_signal_copy (const DisplayStrobeSignal* self, DisplayStrobeSignal* dest);
void display_strobe_signal_destroy (DisplayStrobeSignal* self);
void display_draw_strobes (Display* self, DisplayStrobeSignal* signals, int signals_length1);
void display_render_note (Display* self, const gchar* letter, const gchar* sign, const gchar* octave);
void display_draw_level (Display* self, gfloat level);
void display_draw_signal (Display* self, gfloat* signal, int signal_length1, gfloat gain);
void display_draw_wheel (Display* self, gfloat* signal, int signal_length1, gfloat gain);
GType rgb_get_type (void) G_GNUC_CONST;
RGB* rgb_dup (const RGB* self);
void rgb_free (RGB* self);
void display_draw_stripes (Display* self, gfloat* signal, int signal_length1, gfloat gain, gfloat width, gfloat height, RGB* fg);
void display_strobe_display (Display* self, DisplayStrobeSignal* strobe_signals, int strobe_signals_length1, gfloat gain, RGB* bg, RGB* fg);
void display_window_background (Display* self);
static void display_normalize (Display* self, gfloat* data, int data_length1);
static gfloat* _vala_array_dup2 (gfloat* self, int length);


Display* display_construct (GType object_type, const gchar* title, gint width, gint height) {
	Display* self = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (title != NULL, NULL);
	_tmp0_ = title;
	_tmp1_ = width;
	_tmp2_ = height;
	self = (Display*) gl_cairo_window_construct (object_type, _tmp0_, _tmp1_, _tmp2_);
	display_set_font (self);
	return self;
}


Display* display_new (const gchar* title, gint width, gint height) {
	return display_construct (TYPE_DISPLAY, title, width, height);
}


void display_set_font (Display* self) {
	cairo_font_face_t* font_face = NULL;
	cairo_t* _tmp3_;
	cairo_font_face_t* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		cairo_font_face_t* _tmp0_ = NULL;
		cairo_font_face_t* _tmp1_;
		_tmp0_ = font_loader_load ("fonts/DejaVuSansMono.ttf", &_inner_error_);
		_tmp1_ = _tmp0_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		_cairo_font_face_destroy0 (font_face);
		font_face = _tmp1_;
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		FILE* _tmp2_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = stderr;
		fputs ("Error! Font file is missing.\n", _tmp2_);
		_g_error_free0 (e);
		_cairo_font_face_destroy0 (font_face);
		return;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_cairo_font_face_destroy0 (font_face);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = ((GLCairoWindow*) self)->context;
	_tmp4_ = font_face;
	cairo_set_font_face (_tmp3_, _tmp4_);
	_cairo_font_face_destroy0 (font_face);
}


void display_init_text_layouts (Display* self) {
	g_return_if_fail (self != NULL);
}


void display_draw_strobe (Display* self, gfloat* data, int data_length1) {
	g_return_if_fail (self != NULL);
}


void display_draw_strobes (Display* self, DisplayStrobeSignal* signals, int signals_length1) {
	g_return_if_fail (self != NULL);
}


void display_render_note (Display* self, const gchar* letter, const gchar* sign, const gchar* octave) {
	cairo_text_extents_t extents1 = {0};
	cairo_text_extents_t extents2 = {0};
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	cairo_t* _tmp2_;
	const gchar* _tmp3_;
	cairo_text_extents_t _tmp4_ = {0};
	cairo_t* _tmp5_;
	cairo_t* _tmp6_;
	const gchar* _tmp7_;
	cairo_text_extents_t _tmp8_ = {0};
	cairo_t* _tmp9_;
	gint _tmp10_;
	cairo_text_extents_t _tmp11_;
	gdouble _tmp12_;
	cairo_text_extents_t _tmp13_;
	gdouble _tmp14_;
	cairo_t* _tmp15_;
	cairo_t* _tmp16_;
	const gchar* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* _tmp19_;
	const gchar* _tmp20_;
	cairo_t* _tmp21_;
	cairo_text_extents_t _tmp22_;
	gdouble _tmp23_;
	cairo_text_extents_t _tmp24_;
	gdouble _tmp25_;
	cairo_t* _tmp26_;
	const gchar* _tmp27_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (letter != NULL);
	g_return_if_fail (sign != NULL);
	g_return_if_fail (octave != NULL);
	_tmp0_ = ((GLCairoWindow*) self)->context;
	cairo_set_source_rgba (_tmp0_, 1.0, 1.0, 1.0, 0.9);
	_tmp1_ = ((GLCairoWindow*) self)->context;
	cairo_set_font_size (_tmp1_, (gdouble) 96);
	_tmp2_ = ((GLCairoWindow*) self)->context;
	_tmp3_ = letter;
	cairo_text_extents (_tmp2_, _tmp3_, &_tmp4_);
	extents1 = _tmp4_;
	_tmp5_ = ((GLCairoWindow*) self)->context;
	cairo_set_font_size (_tmp5_, (gdouble) 32);
	_tmp6_ = ((GLCairoWindow*) self)->context;
	_tmp7_ = octave;
	cairo_text_extents (_tmp6_, _tmp7_, &_tmp8_);
	extents2 = _tmp8_;
	_tmp9_ = ((GLCairoWindow*) self)->context;
	_tmp10_ = ((GLCairoWindow*) self)->window_width;
	_tmp11_ = extents1;
	_tmp12_ = _tmp11_.width;
	_tmp13_ = extents2;
	_tmp14_ = _tmp13_.width;
	cairo_move_to (_tmp9_, ((_tmp10_ - _tmp12_) - _tmp14_) / 2, (gdouble) 100);
	_tmp15_ = ((GLCairoWindow*) self)->context;
	cairo_set_font_size (_tmp15_, (gdouble) 96);
	_tmp16_ = ((GLCairoWindow*) self)->context;
	_tmp17_ = letter;
	cairo_show_text (_tmp16_, _tmp17_);
	_tmp18_ = ((GLCairoWindow*) self)->context;
	cairo_set_font_size (_tmp18_, (gdouble) 32);
	_tmp19_ = ((GLCairoWindow*) self)->context;
	_tmp20_ = octave;
	cairo_show_text (_tmp19_, _tmp20_);
	_tmp21_ = ((GLCairoWindow*) self)->context;
	_tmp22_ = extents2;
	_tmp23_ = _tmp22_.width;
	_tmp24_ = extents2;
	_tmp25_ = _tmp24_.height;
	cairo_rel_move_to (_tmp21_, -_tmp23_, -_tmp25_);
	_tmp26_ = ((GLCairoWindow*) self)->context;
	_tmp27_ = sign;
	cairo_show_text (_tmp26_, _tmp27_);
}


void display_draw_level (Display* self, gfloat level) {
	cairo_t* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	cairo_t* _tmp3_;
	cairo_t* _tmp4_;
	gfloat _tmp5_;
	cairo_t* _tmp6_;
	cairo_t* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((GLCairoWindow*) self)->context;
	_tmp1_ = ((GLCairoWindow*) self)->window_width;
	_tmp2_ = ((GLCairoWindow*) self)->window_height;
	cairo_scale (_tmp0_, (gdouble) _tmp1_, (gdouble) _tmp2_);
	_tmp3_ = ((GLCairoWindow*) self)->context;
	cairo_translate (_tmp3_, (gdouble) 0, 0.5);
	_tmp4_ = ((GLCairoWindow*) self)->context;
	_tmp5_ = level;
	cairo_rectangle (_tmp4_, (gdouble) 0, -0.1, (gdouble) _tmp5_, 0.2);
	_tmp6_ = ((GLCairoWindow*) self)->context;
	cairo_set_source_rgb (_tmp6_, 0.4, 0.8, 0.7);
	_tmp7_ = ((GLCairoWindow*) self)->context;
	cairo_fill (_tmp7_);
}


void display_draw_signal (Display* self, gfloat* signal, int signal_length1, gfloat gain) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat dx;
	gfloat x;
	cairo_t* _tmp1_;
	cairo_t* _tmp2_;
	cairo_t* _tmp3_;
	gfloat _tmp4_;
	gfloat* _tmp5_;
	gint _tmp5__length1;
	gfloat _tmp6_;
	gfloat _tmp7_;
	cairo_t* _tmp21_;
	g_return_if_fail (self != NULL);
	_tmp0_ = signal;
	_tmp0__length1 = signal_length1;
	dx = ((gfloat) 1.f) / (_tmp0__length1 - 1);
	x = 0.f;
	_tmp1_ = ((GLCairoWindow*) self)->context;
	cairo_set_line_width (_tmp1_, 0.001);
	_tmp2_ = ((GLCairoWindow*) self)->context;
	cairo_set_source_rgb (_tmp2_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
	_tmp3_ = ((GLCairoWindow*) self)->context;
	_tmp4_ = x;
	_tmp5_ = signal;
	_tmp5__length1 = signal_length1;
	_tmp6_ = _tmp5_[0];
	_tmp7_ = gain;
	cairo_move_to (_tmp3_, (gdouble) _tmp4_, (gdouble) ((-_tmp6_) * _tmp7_));
	{
		gint i;
		i = 1;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gboolean _tmp9_;
				gint _tmp11_;
				gfloat* _tmp12_;
				gint _tmp12__length1;
				gfloat _tmp13_;
				gfloat _tmp14_;
				cairo_t* _tmp15_;
				gfloat _tmp16_;
				gfloat* _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				gfloat _tmp19_;
				gfloat _tmp20_;
				_tmp9_ = _tmp8_;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp11_ = i;
				_tmp12_ = signal;
				_tmp12__length1 = signal_length1;
				if (!(_tmp11_ < _tmp12__length1)) {
					break;
				}
				_tmp13_ = x;
				_tmp14_ = dx;
				x = _tmp13_ + _tmp14_;
				_tmp15_ = ((GLCairoWindow*) self)->context;
				_tmp16_ = x;
				_tmp17_ = signal;
				_tmp17__length1 = signal_length1;
				_tmp18_ = i;
				_tmp19_ = _tmp17_[_tmp18_];
				_tmp20_ = gain;
				cairo_line_to (_tmp15_, (gdouble) _tmp16_, (gdouble) ((-_tmp19_) * _tmp20_));
			}
		}
	}
	_tmp21_ = ((GLCairoWindow*) self)->context;
	cairo_stroke (_tmp21_);
}


void display_draw_wheel (Display* self, gfloat* signal, int signal_length1, gfloat gain) {
	static const gdouble RADIUS_1 = 0.36;
	static const gdouble RADIUS_2 = 0.42;
	cairo_t* _tmp0_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	cairo_t* _tmp2_;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	gdouble angle;
	gfloat* _tmp4_;
	gint _tmp4__length1;
	gfloat* _tmp12_;
	gint _tmp12__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((GLCairoWindow*) self)->context;
	_tmp1_ = signal;
	_tmp1__length1 = signal_length1;
	cairo_set_line_width (_tmp0_, ((0.2 * G_PI) * RADIUS_1) / _tmp1__length1);
	_tmp2_ = ((GLCairoWindow*) self)->context;
	cairo_set_line_cap (_tmp2_, CAIRO_LINE_CAP_SQUARE);
	_tmp3_ = signal;
	_tmp3__length1 = signal_length1;
	angle = ((-G_PI) * 2) / _tmp3__length1;
	_tmp4_ = signal;
	_tmp4__length1 = signal_length1;
	{
		gfloat* sample_collection = NULL;
		gint sample_collection_length1 = 0;
		gint _sample_collection_size_ = 0;
		gint sample_it = 0;
		sample_collection = _tmp4_;
		sample_collection_length1 = _tmp4__length1;
		for (sample_it = 0; sample_it < _tmp4__length1; sample_it = sample_it + 1) {
			gfloat sample = 0.0F;
			sample = sample_collection[sample_it];
			{
				cairo_t* _tmp5_;
				cairo_t* _tmp6_;
				cairo_t* _tmp7_;
				cairo_t* _tmp8_;
				cairo_t* _tmp9_;
				gdouble _tmp10_;
				cairo_t* _tmp11_;
				_tmp5_ = ((GLCairoWindow*) self)->context;
				cairo_set_source_rgba (_tmp5_, 0.6, 0.8, (gdouble) 1, 0.1);
				_tmp6_ = ((GLCairoWindow*) self)->context;
				cairo_move_to (_tmp6_, (gdouble) 0, RADIUS_1);
				_tmp7_ = ((GLCairoWindow*) self)->context;
				cairo_line_to (_tmp7_, (gdouble) 0, RADIUS_2);
				_tmp8_ = ((GLCairoWindow*) self)->context;
				cairo_move_to (_tmp8_, (gdouble) 0, (gdouble) 0);
				_tmp9_ = ((GLCairoWindow*) self)->context;
				_tmp10_ = angle;
				cairo_rotate (_tmp9_, _tmp10_);
				_tmp11_ = ((GLCairoWindow*) self)->context;
				cairo_stroke (_tmp11_);
			}
		}
	}
	_tmp12_ = signal;
	_tmp12__length1 = signal_length1;
	{
		gfloat* sample_collection = NULL;
		gint sample_collection_length1 = 0;
		gint _sample_collection_size_ = 0;
		gint sample_it = 0;
		sample_collection = _tmp12_;
		sample_collection_length1 = _tmp12__length1;
		for (sample_it = 0; sample_it < _tmp12__length1; sample_it = sample_it + 1) {
			gfloat sample = 0.0F;
			sample = sample_collection[sample_it];
			{
				cairo_t* _tmp13_;
				gfloat _tmp14_;
				gfloat _tmp15_;
				cairo_t* _tmp16_;
				cairo_t* _tmp17_;
				cairo_t* _tmp18_;
				cairo_t* _tmp19_;
				gdouble _tmp20_;
				cairo_t* _tmp21_;
				_tmp13_ = ((GLCairoWindow*) self)->context;
				_tmp14_ = gain;
				_tmp15_ = sample;
				cairo_set_source_rgba (_tmp13_, (gdouble) 1, (gdouble) 1, (gdouble) 1, (gdouble) (_tmp14_ * _tmp15_));
				_tmp16_ = ((GLCairoWindow*) self)->context;
				cairo_move_to (_tmp16_, (gdouble) 0, RADIUS_1);
				_tmp17_ = ((GLCairoWindow*) self)->context;
				cairo_line_to (_tmp17_, (gdouble) 0, RADIUS_2);
				_tmp18_ = ((GLCairoWindow*) self)->context;
				cairo_move_to (_tmp18_, (gdouble) 0, (gdouble) 0);
				_tmp19_ = ((GLCairoWindow*) self)->context;
				_tmp20_ = angle;
				cairo_rotate (_tmp19_, _tmp20_);
				_tmp21_ = ((GLCairoWindow*) self)->context;
				cairo_stroke (_tmp21_);
			}
		}
	}
}


void display_draw_stripes (Display* self, gfloat* signal, int signal_length1, gfloat gain, gfloat width, gfloat height, RGB* fg) {
	gfloat _tmp0_;
	cairo_pattern_t* _tmp1_;
	cairo_pattern_t* gradient;
	cairo_pattern_t* _tmp2_;
	gfloat x;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	gfloat dx;
	gint count;
	gfloat* _tmp4_;
	gint _tmp4__length1;
	cairo_t* _tmp18_;
	gfloat _tmp19_;
	gfloat _tmp20_;
	cairo_t* _tmp21_;
	cairo_pattern_t* _tmp22_;
	cairo_t* _tmp23_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (fg != NULL);
	_tmp0_ = width;
	_tmp1_ = cairo_pattern_create_linear ((gdouble) 0, (gdouble) 0, (gdouble) _tmp0_, (gdouble) 0);
	gradient = _tmp1_;
	_tmp2_ = gradient;
	cairo_pattern_set_filter (_tmp2_, CAIRO_FILTER_FAST);
	x = 1.f;
	_tmp3_ = signal;
	_tmp3__length1 = signal_length1;
	dx = 1.f / (_tmp3__length1 - 1);
	count = 0;
	_tmp4_ = signal;
	_tmp4__length1 = signal_length1;
	{
		gfloat* sample_collection = NULL;
		gint sample_collection_length1 = 0;
		gint _sample_collection_size_ = 0;
		gint sample_it = 0;
		sample_collection = _tmp4_;
		sample_collection_length1 = _tmp4__length1;
		for (sample_it = 0; sample_it < _tmp4__length1; sample_it = sample_it + 1) {
			gfloat sample = 0.0F;
			sample = sample_collection[sample_it];
			{
				cairo_pattern_t* _tmp5_;
				gfloat _tmp6_;
				RGB _tmp7_;
				gfloat _tmp8_;
				RGB _tmp9_;
				gfloat _tmp10_;
				RGB _tmp11_;
				gfloat _tmp12_;
				gfloat _tmp13_;
				gfloat _tmp14_;
				gfloat _tmp15_;
				gfloat _tmp16_;
				gint _tmp17_;
				_tmp5_ = gradient;
				_tmp6_ = x;
				_tmp7_ = *fg;
				_tmp8_ = _tmp7_.r;
				_tmp9_ = *fg;
				_tmp10_ = _tmp9_.g;
				_tmp11_ = *fg;
				_tmp12_ = _tmp11_.b;
				_tmp13_ = gain;
				_tmp14_ = sample;
				cairo_pattern_add_color_stop_rgba (_tmp5_, (gdouble) _tmp6_, (gdouble) _tmp8_, (gdouble) _tmp10_, (gdouble) _tmp12_, (gdouble) (_tmp13_ * _tmp14_));
				_tmp15_ = x;
				_tmp16_ = dx;
				x = _tmp15_ - _tmp16_;
				_tmp17_ = count;
				count = _tmp17_ + 1;
			}
		}
	}
	_tmp18_ = ((GLCairoWindow*) self)->context;
	_tmp19_ = width;
	_tmp20_ = height;
	cairo_rectangle (_tmp18_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp19_, (gdouble) _tmp20_);
	_tmp21_ = ((GLCairoWindow*) self)->context;
	_tmp22_ = gradient;
	cairo_set_source (_tmp21_, _tmp22_);
	_tmp23_ = ((GLCairoWindow*) self)->context;
	cairo_fill (_tmp23_);
	_cairo_pattern_destroy0 (gradient);
}


void display_strobe_display (Display* self, DisplayStrobeSignal* strobe_signals, int strobe_signals_length1, gfloat gain, RGB* bg, RGB* fg) {
	DisplayStrobeSignal* _tmp0_;
	gint _tmp0__length1;
	gint len;
	cairo_t* _tmp1_;
	RGB _tmp2_;
	gfloat _tmp3_;
	RGB _tmp4_;
	gfloat _tmp5_;
	RGB _tmp6_;
	gfloat _tmp7_;
	cairo_t* _tmp8_;
	gint _tmp9_;
	cairo_t* _tmp10_;
	cairo_t* _tmp11_;
	cairo_t* _tmp12_;
	DisplayStrobeSignal* _tmp13_;
	gint _tmp13__length1;
	cairo_t* _tmp20_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (bg != NULL);
	g_return_if_fail (fg != NULL);
	_tmp0_ = strobe_signals;
	_tmp0__length1 = strobe_signals_length1;
	len = _tmp0__length1;
	_tmp1_ = ((GLCairoWindow*) self)->context;
	_tmp2_ = *bg;
	_tmp3_ = _tmp2_.r;
	_tmp4_ = *bg;
	_tmp5_ = _tmp4_.g;
	_tmp6_ = *bg;
	_tmp7_ = _tmp6_.b;
	cairo_set_source_rgb (_tmp1_, (gdouble) _tmp3_, (gdouble) _tmp5_, (gdouble) _tmp7_);
	_tmp8_ = ((GLCairoWindow*) self)->context;
	_tmp9_ = len;
	cairo_rectangle (_tmp8_, (gdouble) 40, (gdouble) 200, (gdouble) 420, (gdouble) (81 * _tmp9_));
	_tmp10_ = ((GLCairoWindow*) self)->context;
	cairo_fill (_tmp10_);
	_tmp11_ = ((GLCairoWindow*) self)->context;
	cairo_save (_tmp11_);
	_tmp12_ = ((GLCairoWindow*) self)->context;
	cairo_translate (_tmp12_, (gdouble) 40, (gdouble) 200);
	_tmp13_ = strobe_signals;
	_tmp13__length1 = strobe_signals_length1;
	{
		DisplayStrobeSignal* signal_collection = NULL;
		gint signal_collection_length1 = 0;
		gint _signal_collection_size_ = 0;
		gint signal_it = 0;
		signal_collection = _tmp13_;
		signal_collection_length1 = _tmp13__length1;
		for (signal_it = 0; signal_it < _tmp13__length1; signal_it = signal_it + 1) {
			DisplayStrobeSignal _tmp14_ = {0};
			DisplayStrobeSignal signal = {0};
			display_strobe_signal_copy (&signal_collection[signal_it], &_tmp14_);
			signal = _tmp14_;
			{
				DisplayStrobeSignal _tmp15_;
				gfloat* _tmp16_;
				gint _tmp16__length1;
				gfloat _tmp17_;
				RGB _tmp18_;
				cairo_t* _tmp19_;
				_tmp15_ = signal;
				_tmp16_ = _tmp15_.data;
				_tmp16__length1 = _tmp15_.data_length1;
				_tmp17_ = gain;
				_tmp18_ = *fg;
				display_draw_stripes (self, _tmp16_, _tmp16__length1, _tmp17_, (gfloat) 420, (gfloat) 80, &_tmp18_);
				_tmp19_ = ((GLCairoWindow*) self)->context;
				cairo_translate (_tmp19_, (gdouble) 0, (gdouble) 81);
				display_strobe_signal_destroy (&signal);
			}
		}
	}
	_tmp20_ = ((GLCairoWindow*) self)->context;
	cairo_restore (_tmp20_);
}


void display_window_background (Display* self) {
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((GLCairoWindow*) self)->context;
	cairo_set_source_rgb (_tmp0_, 0.0, 0.0, 0.0);
	_tmp1_ = ((GLCairoWindow*) self)->context;
	cairo_paint (_tmp1_);
}


static void display_normalize (Display* self, gfloat* data, int data_length1) {
	gfloat max;
	gfloat _tmp19_;
	gfloat k;
	g_return_if_fail (self != NULL);
	max = 0.f;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				gfloat* _tmp4_;
				gint _tmp4__length1;
				gfloat* _tmp5_;
				gint _tmp5__length1;
				gint _tmp6_;
				gfloat _tmp7_;
				gfloat _tmp8_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = data;
				_tmp4__length1 = data_length1;
				if (!(_tmp3_ < _tmp4__length1)) {
					break;
				}
				_tmp5_ = data;
				_tmp5__length1 = data_length1;
				_tmp6_ = i;
				_tmp7_ = _tmp5_[_tmp6_];
				_tmp8_ = max;
				if (_tmp7_ > _tmp8_) {
					gfloat* _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					gfloat _tmp11_;
					_tmp9_ = data;
					_tmp9__length1 = data_length1;
					_tmp10_ = i;
					_tmp11_ = _tmp9_[_tmp10_];
					max = _tmp11_;
				} else {
					gfloat* _tmp12_;
					gint _tmp12__length1;
					gint _tmp13_;
					gfloat _tmp14_;
					gfloat _tmp15_;
					_tmp12_ = data;
					_tmp12__length1 = data_length1;
					_tmp13_ = i;
					_tmp14_ = _tmp12_[_tmp13_];
					_tmp15_ = max;
					if (_tmp14_ < (-_tmp15_)) {
						gfloat* _tmp16_;
						gint _tmp16__length1;
						gint _tmp17_;
						gfloat _tmp18_;
						_tmp16_ = data;
						_tmp16__length1 = data_length1;
						_tmp17_ = i;
						_tmp18_ = _tmp16_[_tmp17_];
						max = -_tmp18_;
					}
				}
			}
		}
	}
	_tmp19_ = max;
	k = 1.f / _tmp19_;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp20_;
			_tmp20_ = TRUE;
			while (TRUE) {
				gboolean _tmp21_;
				gint _tmp23_;
				gfloat* _tmp24_;
				gint _tmp24__length1;
				gfloat* _tmp25_;
				gint _tmp25__length1;
				gint _tmp26_;
				gfloat _tmp27_;
				gfloat _tmp28_;
				_tmp21_ = _tmp20_;
				if (!_tmp21_) {
					gint _tmp22_;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp20_ = FALSE;
				_tmp23_ = i;
				_tmp24_ = data;
				_tmp24__length1 = data_length1;
				if (!(_tmp23_ < _tmp24__length1)) {
					break;
				}
				_tmp25_ = data;
				_tmp25__length1 = data_length1;
				_tmp26_ = i;
				_tmp27_ = k;
				_tmp25_[_tmp26_] *= _tmp27_;
				_tmp28_ = _tmp25_[_tmp26_];
			}
		}
	}
}


static gfloat* _vala_array_dup2 (gfloat* self, int length) {
	return g_memdup (self, length * sizeof (gfloat));
}


void display_strobe_signal_copy (const DisplayStrobeSignal* self, DisplayStrobeSignal* dest) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat* _tmp3_;
	gint _tmp3__length1;
	_tmp0_ = (*self).name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).name);
	(*dest).name = _tmp1_;
	_tmp2_ = (*self).data;
	_tmp2__length1 = (*self).data_length1;
	_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup2 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
	_tmp3__length1 = _tmp2__length1;
	(*dest).data = (g_free ((*dest).data), NULL);
	(*dest).data = _tmp3_;
	(*dest).data_length1 = _tmp3__length1;
}


void display_strobe_signal_destroy (DisplayStrobeSignal* self) {
	_g_free0 ((*self).name);
	(*self).data = (g_free ((*self).data), NULL);
}


DisplayStrobeSignal* display_strobe_signal_dup (const DisplayStrobeSignal* self) {
	DisplayStrobeSignal* dup;
	dup = g_new0 (DisplayStrobeSignal, 1);
	display_strobe_signal_copy (self, dup);
	return dup;
}


void display_strobe_signal_free (DisplayStrobeSignal* self) {
	display_strobe_signal_destroy (self);
	g_free (self);
}


GType display_strobe_signal_get_type (void) {
	static volatile gsize display_strobe_signal_type_id__volatile = 0;
	if (g_once_init_enter (&display_strobe_signal_type_id__volatile)) {
		GType display_strobe_signal_type_id;
		display_strobe_signal_type_id = g_boxed_type_register_static ("DisplayStrobeSignal", (GBoxedCopyFunc) display_strobe_signal_dup, (GBoxedFreeFunc) display_strobe_signal_free);
		g_once_init_leave (&display_strobe_signal_type_id__volatile, display_strobe_signal_type_id);
	}
	return display_strobe_signal_type_id__volatile;
}


static void display_class_init (DisplayClass * klass) {
	display_parent_class = g_type_class_peek_parent (klass);
}


static void display_instance_init (Display * self) {
}


GType display_get_type (void) {
	static volatile gsize display_type_id__volatile = 0;
	if (g_once_init_enter (&display_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DisplayClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) display_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Display), 0, (GInstanceInitFunc) display_instance_init, NULL };
		GType display_type_id;
		display_type_id = g_type_register_static (TYPE_GL_CAIRO_WINDOW, "Display", &g_define_type_info, 0);
		g_once_init_leave (&display_type_id__volatile, display_type_id);
	}
	return display_type_id__volatile;
}



