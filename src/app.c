/* app.c generated by valac 0.18.1, the Vala compiler
 * generated from app.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <cairo.h>
#include "OpenGL/gl.h"
#include "portaudio.h"
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define TYPE_GL_CAIRO_WINDOW (gl_cairo_window_get_type ())
#define GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindow))
#define GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))
#define IS_GL_CAIRO_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GL_CAIRO_WINDOW))
#define IS_GL_CAIRO_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GL_CAIRO_WINDOW))
#define GL_CAIRO_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GL_CAIRO_WINDOW, GLCairoWindowClass))

typedef struct _GLCairoWindow GLCairoWindow;
typedef struct _GLCairoWindowClass GLCairoWindowClass;
typedef struct _GLCairoWindowPrivate GLCairoWindowPrivate;

#define TYPE_DISPLAY (display_get_type ())
#define DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DISPLAY, Display))
#define DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DISPLAY, DisplayClass))
#define IS_DISPLAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DISPLAY))
#define IS_DISPLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DISPLAY))
#define DISPLAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DISPLAY, DisplayClass))

typedef struct _Display Display;
typedef struct _DisplayClass DisplayClass;
typedef struct _DisplayPrivate DisplayPrivate;

#define TYPE_APP (app_get_type ())
#define APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP, App))
#define APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP, AppClass))
#define IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP))
#define IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP))
#define APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP, AppClass))

typedef struct _App App;
typedef struct _AppClass AppClass;
typedef struct _AppPrivate AppPrivate;

#define TYPE_CONFIG (config_get_type ())
#define CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG, Config))
#define CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG, ConfigClass))
#define IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG))
#define IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG))
#define CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG, ConfigClass))

typedef struct _Config Config;
typedef struct _ConfigClass ConfigClass;

#define TYPE_CONVERTER (converter_get_type ())
#define CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONVERTER, Converter))
#define CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONVERTER, ConverterClass))
#define IS_CONVERTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONVERTER))
#define IS_CONVERTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONVERTER))
#define CONVERTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONVERTER, ConverterClass))

typedef struct _Converter Converter;
typedef struct _ConverterClass ConverterClass;

#define TYPE_PITCH_ESTIMATION (pitch_estimation_get_type ())
#define PITCH_ESTIMATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PITCH_ESTIMATION, PitchEstimation))
#define PITCH_ESTIMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PITCH_ESTIMATION, PitchEstimationClass))
#define IS_PITCH_ESTIMATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PITCH_ESTIMATION))
#define IS_PITCH_ESTIMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PITCH_ESTIMATION))
#define PITCH_ESTIMATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PITCH_ESTIMATION, PitchEstimationClass))

typedef struct _PitchEstimation PitchEstimation;
typedef struct _PitchEstimationClass PitchEstimationClass;

#define TUNING_12_TET_TYPE_NOTE (tuning_12_tet_note_get_type ())
typedef struct _Tuning12TETNote Tuning12TETNote;

#define TYPE_STROBE (strobe_get_type ())
#define STROBE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STROBE, Strobe))
#define STROBE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STROBE, StrobeClass))
#define IS_STROBE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STROBE))
#define IS_STROBE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STROBE))
#define STROBE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STROBE, StrobeClass))

typedef struct _Strobe Strobe;
typedef struct _StrobeClass StrobeClass;

#define DISPLAY_TYPE_STROBE_SIGNAL (display_strobe_signal_get_type ())
typedef struct _DisplayStrobeSignal DisplayStrobeSignal;
#define _config_unref0(var) ((var == NULL) ? NULL : (var = (config_unref (var), NULL)))
#define _converter_unref0(var) ((var == NULL) ? NULL : (var = (converter_unref (var), NULL)))
#define _pitch_estimation_unref0(var) ((var == NULL) ? NULL : (var = (pitch_estimation_unref (var), NULL)))
#define _Pa_CloseStream0(var) ((var == NULL) ? NULL : (var = (Pa_CloseStream (var), NULL)))
typedef struct _ConfigPrivate ConfigPrivate;

#define TYPE_RGB (rgb_get_type ())
typedef struct _RGB RGB;
#define _strobe_unref0(var) ((var == NULL) ? NULL : (var = (strobe_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _gl_cairo_window_unref0(var) ((var == NULL) ? NULL : (var = (gl_cairo_window_unref (var), NULL)))

struct _GLCairoWindow {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GLCairoWindowPrivate * priv;
	cairo_surface_t* surface;
	cairo_t* context;
	guchar* surface_data;
	gint surface_data_length1;
	gboolean quit;
	gint window_width;
	gint window_height;
	GLuint* textures;
	gint textures_length1;
};

struct _GLCairoWindowClass {
	GTypeClass parent_class;
	void (*finalize) (GLCairoWindow *self);
};

struct _Display {
	GLCairoWindow parent_instance;
	DisplayPrivate * priv;
};

struct _DisplayClass {
	GLCairoWindowClass parent_class;
};

struct _App {
	Display parent_instance;
	AppPrivate * priv;
};

struct _AppClass {
	DisplayClass parent_class;
};

struct _Tuning12TETNote {
	gchar* letter;
	gchar* sign;
	gchar* alt_letter;
	gchar* alt_sign;
	gint octave;
	gfloat cents;
	gfloat frequency;
};

struct _DisplayStrobeSignal {
	gchar* name;
	gfloat* data;
	gint data_length1;
};

struct _AppPrivate {
	Config* config;
	Converter* converter;
	PitchEstimation* pitch_estimation;
	PaStream* stream;
	Tuning12TETNote note;
	gfloat pitch;
	gfloat* audio_signal;
	gint audio_signal_length1;
	gint _audio_signal_size_;
	GRecMutex __lock_audio_signal;
	Strobe** strobes;
	gint strobes_length1;
	gint _strobes_size_;
	DisplayStrobeSignal* strobe_signals;
	gint strobe_signals_length1;
	gint _strobe_signals_size_;
	GRecMutex __lock_strobe_signals;
	gint estimation_delay;
	gint strobe_delay;
	gfloat peak;
	gfloat threshold;
	gboolean above;
	gboolean manual_mode;
	gboolean instrument_mode;
};

struct _RGB {
	gfloat r;
	gfloat g;
	gfloat b;
};

struct _Config {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ConfigPrivate * priv;
	gint sample_rate;
	gint fft_sample_rate;
	gint fft_length;
	gint buffer_length;
	gint resampled_buffer_length;
	gint periods_per_frame;
	gint estimation_framerate;
	gint strobe_framerate;
	gfloat audio_threshold;
	gfloat strobe_gain;
	gfloat pitch_standard;
	gboolean display_flats;
	gint transpose;
	gfloat cents_offset;
	gint* partials;
	gint partials_length1;
	gint* samples_per_period;
	gint samples_per_period_length1;
	gfloat* ins_notes;
	gint ins_notes_length1;
	RGB strobe_background;
	RGB strobe_foreground;
};

struct _ConfigClass {
	GTypeClass parent_class;
	void (*finalize) (Config *self);
};


static gpointer app_parent_class = NULL;

gpointer gl_cairo_window_ref (gpointer instance);
void gl_cairo_window_unref (gpointer instance);
GParamSpec* param_spec_gl_cairo_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gl_cairo_window (GValue* value, gpointer v_object);
void value_take_gl_cairo_window (GValue* value, gpointer v_object);
gpointer value_get_gl_cairo_window (const GValue* value);
GType gl_cairo_window_get_type (void) G_GNUC_CONST;
GType display_get_type (void) G_GNUC_CONST;
GType app_get_type (void) G_GNUC_CONST;
gpointer config_ref (gpointer instance);
void config_unref (gpointer instance);
GParamSpec* param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_config (GValue* value, gpointer v_object);
void value_take_config (GValue* value, gpointer v_object);
gpointer value_get_config (const GValue* value);
GType config_get_type (void) G_GNUC_CONST;
gpointer converter_ref (gpointer instance);
void converter_unref (gpointer instance);
GParamSpec* param_spec_converter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_converter (GValue* value, gpointer v_object);
void value_take_converter (GValue* value, gpointer v_object);
gpointer value_get_converter (const GValue* value);
GType converter_get_type (void) G_GNUC_CONST;
gpointer pitch_estimation_ref (gpointer instance);
void pitch_estimation_unref (gpointer instance);
GParamSpec* param_spec_pitch_estimation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_pitch_estimation (GValue* value, gpointer v_object);
void value_take_pitch_estimation (GValue* value, gpointer v_object);
gpointer value_get_pitch_estimation (const GValue* value);
GType pitch_estimation_get_type (void) G_GNUC_CONST;
GType tuning_12_tet_note_get_type (void) G_GNUC_CONST;
Tuning12TETNote* tuning_12_tet_note_dup (const Tuning12TETNote* self);
void tuning_12_tet_note_free (Tuning12TETNote* self);
void tuning_12_tet_note_copy (const Tuning12TETNote* self, Tuning12TETNote* dest);
void tuning_12_tet_note_destroy (Tuning12TETNote* self);
gpointer strobe_ref (gpointer instance);
void strobe_unref (gpointer instance);
GParamSpec* param_spec_strobe (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_strobe (GValue* value, gpointer v_object);
void value_take_strobe (GValue* value, gpointer v_object);
gpointer value_get_strobe (const GValue* value);
GType strobe_get_type (void) G_GNUC_CONST;
GType display_strobe_signal_get_type (void) G_GNUC_CONST;
DisplayStrobeSignal* display_strobe_signal_dup (const DisplayStrobeSignal* self);
void display_strobe_signal_free (DisplayStrobeSignal* self);
void display_strobe_signal_copy (const DisplayStrobeSignal* self, DisplayStrobeSignal* dest);
void display_strobe_signal_destroy (DisplayStrobeSignal* self);
#define APP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APP, AppPrivate))
enum  {
	APP_DUMMY_PROPERTY
};
static void _vala_DisplayStrobeSignal_array_free (DisplayStrobeSignal* array, gint array_length);
App* app_new (void);
App* app_construct (GType object_type);
Display* display_new (const gchar* title, gint width, gint height);
Display* display_construct (GType object_type, const gchar* title, gint width, gint height);
Config* config_new (const gchar* filename);
Config* config_construct (GType object_type, const gchar* filename);
GType rgb_get_type (void) G_GNUC_CONST;
RGB* rgb_dup (const RGB* self);
void rgb_free (RGB* self);
Converter* converter_new (gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate);
Converter* converter_construct (GType object_type, gint buffer_length, gint fft_sample_rate, gint lowpass_cutoff, gint highpass_cutoff, gint sample_rate);
PitchEstimation* pitch_estimation_new (gint sample_rate, gint data_length);
PitchEstimation* pitch_estimation_construct (GType object_type, gint sample_rate, gint data_length);
static gint* _vala_array_dup1 (gint* self, int length);
Strobe* strobe_new (gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period);
Strobe* strobe_construct (GType object_type, gint buffer_length, gint resampled_buffer_length, gint sample_rate, gint samples_per_period);
static gdouble app_from_dbfs (gdouble value);
static gint app_stream_callback (App* self, void* input, void* output, gulong nframes, PaStreamCallbackTimeInfo* time, PaStreamCallbackFlags flags);
static gint _app_stream_callback_pa_stream_callback (void* input, void* output, gulong frame_count, PaStreamCallbackTimeInfo* time_info, PaStreamCallbackFlags status_flags, gpointer self);
static void app_process_signal (App* self, gfloat* input, int input_length1);
void converter_process_signal (Converter* self, gfloat* input, int input_length1);
void strobe_process_signal (Strobe* self, gfloat* input, int input_length1);
static gfloat app_find_peak (App* self, gfloat* buffer, int buffer_length1);
static gdouble app_to_dbfs (gdouble value);
void app_draw (App* self);
void display_window_background (Display* self);
void tuning_12_tet_find_nearest (gfloat freq, gfloat* notes, int notes_length1, gfloat pitch_standard, Tuning12TETNote* result);
void tuning_12_tet_find (gfloat freq, gfloat pitch_standard, gfloat cents_offset, gint transpose, Tuning12TETNote* result);
void display_render_note (Display* self, const gchar* letter, const gchar* sign, const gchar* octave);
void display_strobe_display (Display* self, DisplayStrobeSignal* strobe_signals, int strobe_signals_length1, gfloat gain, RGB* bg, RGB* fg);
gboolean app_above_threshold (App* self);
gint app_strobe (App* self);
void strobe_read (Strobe* self, gfloat** output, int* output_length1);
void strobe_set_target_freq (Strobe* self, gfloat freq);
gint app_find_pitch (App* self);
void converter_read (Converter* self, gfloat** output, int* output_length1);
gfloat pitch_estimation_pitch_from_autocorrelation (PitchEstimation* self, gfloat* data, int data_length1);
gint app_main (gchar** args, int args_length1);
static gpointer _app_find_pitch_gthread_func (gpointer self);
static gpointer _app_strobe_gthread_func (gpointer self);
void gl_cairo_window_process_events (GLCairoWindow* self);
static void app_finalize (GLCairoWindow* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _vala_DisplayStrobeSignal_array_free (DisplayStrobeSignal* array, gint array_length) {
	if (array != NULL) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			display_strobe_signal_destroy (&array[i]);
		}
	}
	g_free (array);
}


static gint* _vala_array_dup1 (gint* self, int length) {
	return g_memdup (self, length * sizeof (gint));
}


static gint _app_stream_callback_pa_stream_callback (void* input, void* output, gulong frame_count, PaStreamCallbackTimeInfo* time_info, PaStreamCallbackFlags status_flags, gpointer self) {
	gint result;
	result = app_stream_callback (self, input, output, frame_count, time_info, status_flags);
	return result;
}


App* app_construct (GType object_type) {
	App* self = NULL;
	Config* _tmp0_;
	Config* _tmp1_;
	gint _tmp2_;
	Config* _tmp3_;
	gint _tmp4_;
	Config* _tmp5_;
	gint _tmp6_;
	Converter* _tmp7_;
	Config* _tmp8_;
	gint _tmp9_;
	Config* _tmp10_;
	gint _tmp11_;
	PitchEstimation* _tmp12_;
	Config* _tmp13_;
	gint* _tmp14_;
	gint _tmp14__length1;
	Strobe** _tmp15_ = NULL;
	Strobe** _tmp16_;
	gint _tmp16__length1;
	DisplayStrobeSignal* _tmp17_ = NULL;
	Config* _tmp18_;
	gint _tmp19_;
	gint _tmp20_ = 0;
	gint estimation_framerate;
	Config* _tmp21_;
	gint _tmp22_;
	gint _tmp23_ = 0;
	gint strobe_framerate;
	gint _tmp24_;
	gint _tmp25_;
	Config* _tmp26_;
	gint* _tmp27_;
	gint _tmp27__length1;
	gint* _tmp28_;
	gint _tmp28__length1;
	gint* samples_per_period;
	gint samples_per_period_length1;
	gint _samples_per_period_size_;
	Config* _tmp65_;
	gfloat _tmp66_;
	gdouble _tmp67_ = 0.0;
	Config* _tmp68_;
	gint _tmp69_;
	gfloat* _tmp70_ = NULL;
	Config* _tmp71_;
	gint _tmp72_;
	PaStream* _tmp73_ = NULL;
	PaStream* _tmp74_;
	self = (App*) display_construct (object_type, "Strobie", 500, 500);
	_tmp0_ = config_new ("config.json");
	_config_unref0 (self->priv->config);
	self->priv->config = _tmp0_;
	_tmp1_ = self->priv->config;
	_tmp2_ = _tmp1_->buffer_length;
	_tmp3_ = self->priv->config;
	_tmp4_ = _tmp3_->fft_sample_rate;
	_tmp5_ = self->priv->config;
	_tmp6_ = _tmp5_->sample_rate;
	_tmp7_ = converter_new (_tmp2_, _tmp4_, 0, 0, _tmp6_);
	_converter_unref0 (self->priv->converter);
	self->priv->converter = _tmp7_;
	_tmp8_ = self->priv->config;
	_tmp9_ = _tmp8_->fft_sample_rate;
	_tmp10_ = self->priv->config;
	_tmp11_ = _tmp10_->fft_length;
	_tmp12_ = pitch_estimation_new (_tmp9_, _tmp11_);
	_pitch_estimation_unref0 (self->priv->pitch_estimation);
	self->priv->pitch_estimation = _tmp12_;
	_tmp13_ = self->priv->config;
	_tmp14_ = _tmp13_->partials;
	_tmp14__length1 = _tmp13_->partials_length1;
	_tmp15_ = g_new0 (Strobe*, _tmp14__length1 + 1);
	self->priv->strobes = (_vala_array_free (self->priv->strobes, self->priv->strobes_length1, (GDestroyNotify) strobe_unref), NULL);
	self->priv->strobes = _tmp15_;
	self->priv->strobes_length1 = _tmp14__length1;
	self->priv->_strobes_size_ = self->priv->strobes_length1;
	_tmp16_ = self->priv->strobes;
	_tmp16__length1 = self->priv->strobes_length1;
	_tmp17_ = g_new0 (DisplayStrobeSignal, _tmp16__length1);
	self->priv->strobe_signals = (_vala_DisplayStrobeSignal_array_free (self->priv->strobe_signals, self->priv->strobe_signals_length1), NULL);
	self->priv->strobe_signals = _tmp17_;
	self->priv->strobe_signals_length1 = _tmp16__length1;
	self->priv->_strobe_signals_size_ = self->priv->strobe_signals_length1;
	_tmp18_ = self->priv->config;
	_tmp19_ = _tmp18_->estimation_framerate;
	_tmp20_ = CLAMP (_tmp19_, 1, 100);
	estimation_framerate = _tmp20_;
	_tmp21_ = self->priv->config;
	_tmp22_ = _tmp21_->strobe_framerate;
	_tmp23_ = CLAMP (_tmp22_, 1, 100);
	strobe_framerate = _tmp23_;
	_tmp24_ = estimation_framerate;
	self->priv->estimation_delay = 1000000 / _tmp24_;
	_tmp25_ = strobe_framerate;
	self->priv->strobe_delay = 1000000 / _tmp25_;
	_tmp26_ = self->priv->config;
	_tmp27_ = _tmp26_->samples_per_period;
	_tmp27__length1 = _tmp26_->samples_per_period_length1;
	_tmp28_ = (_tmp27_ != NULL) ? _vala_array_dup1 (_tmp27_, _tmp27__length1) : ((gpointer) _tmp27_);
	_tmp28__length1 = _tmp27__length1;
	samples_per_period = _tmp28_;
	samples_per_period_length1 = _tmp28__length1;
	_samples_per_period_size_ = samples_per_period_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp29_;
			_tmp29_ = TRUE;
			while (TRUE) {
				gboolean _tmp30_;
				gint _tmp32_;
				Strobe** _tmp33_;
				gint _tmp33__length1;
				Strobe** _tmp34_;
				gint _tmp34__length1;
				gint _tmp35_;
				Config* _tmp36_;
				gint _tmp37_;
				Config* _tmp38_;
				gint _tmp39_;
				Config* _tmp40_;
				gint _tmp41_;
				Config* _tmp42_;
				gint* _tmp43_;
				gint _tmp43__length1;
				gint _tmp44_;
				gint _tmp45_;
				Strobe* _tmp46_;
				Strobe* _tmp47_;
				Config* _tmp48_;
				gint* _tmp49_;
				gint _tmp49__length1;
				gint _tmp50_;
				gint _tmp51_;
				Config* _tmp52_;
				gint _tmp53_;
				Config* _tmp54_;
				gint* _tmp55_;
				gint _tmp55__length1;
				gint _tmp56_;
				gint _tmp57_;
				gint len;
				DisplayStrobeSignal* _tmp58_;
				gint _tmp58__length1;
				gint _tmp59_;
				gchar* _tmp60_;
				gint _tmp61_;
				gfloat* _tmp62_ = NULL;
				DisplayStrobeSignal _tmp63_ = {0};
				DisplayStrobeSignal _tmp64_;
				_tmp30_ = _tmp29_;
				if (!_tmp30_) {
					gint _tmp31_;
					_tmp31_ = i;
					i = _tmp31_ + 1;
				}
				_tmp29_ = FALSE;
				_tmp32_ = i;
				_tmp33_ = self->priv->strobes;
				_tmp33__length1 = self->priv->strobes_length1;
				if (!(_tmp32_ < _tmp33__length1)) {
					break;
				}
				_tmp34_ = self->priv->strobes;
				_tmp34__length1 = self->priv->strobes_length1;
				_tmp35_ = i;
				_tmp36_ = self->priv->config;
				_tmp37_ = _tmp36_->buffer_length;
				_tmp38_ = self->priv->config;
				_tmp39_ = _tmp38_->resampled_buffer_length;
				_tmp40_ = self->priv->config;
				_tmp41_ = _tmp40_->sample_rate;
				_tmp42_ = self->priv->config;
				_tmp43_ = _tmp42_->samples_per_period;
				_tmp43__length1 = _tmp42_->samples_per_period_length1;
				_tmp44_ = i;
				_tmp45_ = _tmp43_[_tmp44_];
				_tmp46_ = strobe_new (_tmp37_, _tmp39_, _tmp41_, _tmp45_);
				_strobe_unref0 (_tmp34_[_tmp35_]);
				_tmp34_[_tmp35_] = _tmp46_;
				_tmp47_ = _tmp34_[_tmp35_];
				_tmp48_ = self->priv->config;
				_tmp49_ = _tmp48_->samples_per_period;
				_tmp49__length1 = _tmp48_->samples_per_period_length1;
				_tmp50_ = i;
				_tmp51_ = _tmp49_[_tmp50_];
				_tmp52_ = self->priv->config;
				_tmp53_ = _tmp52_->periods_per_frame;
				_tmp54_ = self->priv->config;
				_tmp55_ = _tmp54_->partials;
				_tmp55__length1 = _tmp54_->partials_length1;
				_tmp56_ = i;
				_tmp57_ = _tmp55_[_tmp56_];
				len = (gint) ((_tmp51_ * _tmp53_) * _tmp57_);
				_tmp58_ = self->priv->strobe_signals;
				_tmp58__length1 = self->priv->strobe_signals_length1;
				_tmp59_ = i;
				_tmp60_ = g_strdup ("");
				_tmp61_ = len;
				_tmp62_ = g_new0 (gfloat, _tmp61_);
				_g_free0 (_tmp63_.name);
				_tmp63_.name = _tmp60_;
				_tmp63_.data = (g_free (_tmp63_.data), NULL);
				_tmp63_.data = _tmp62_;
				_tmp63_.data_length1 = _tmp61_;
				display_strobe_signal_destroy (&_tmp58_[_tmp59_]);
				_tmp58_[_tmp59_] = _tmp63_;
				_tmp64_ = _tmp58_[_tmp59_];
			}
		}
	}
	_tmp65_ = self->priv->config;
	_tmp66_ = _tmp65_->audio_threshold;
	_tmp67_ = app_from_dbfs ((gdouble) _tmp66_);
	self->priv->threshold = (gfloat) _tmp67_;
	_tmp68_ = self->priv->config;
	_tmp69_ = _tmp68_->fft_length;
	_tmp70_ = g_new0 (gfloat, _tmp69_);
	self->priv->audio_signal = (g_free (self->priv->audio_signal), NULL);
	self->priv->audio_signal = _tmp70_;
	self->priv->audio_signal_length1 = _tmp69_;
	self->priv->_audio_signal_size_ = self->priv->audio_signal_length1;
	Pa_Initialize ();
	_tmp71_ = self->priv->config;
	_tmp72_ = _tmp71_->sample_rate;
	Pa_OpenDefaultStream (&_tmp73_, 1, 0, paFloat32 , (gdouble) _tmp72_, (gulong) paFramesPerBufferUnspecified, _app_stream_callback_pa_stream_callback, self);
	_Pa_CloseStream0 (self->priv->stream);
	self->priv->stream = _tmp73_;
	_tmp74_ = self->priv->stream;
	Pa_StartStream (_tmp74_);
	samples_per_period = (g_free (samples_per_period), NULL);
	return self;
}


App* app_new (void) {
	return app_construct (TYPE_APP);
}


/**
   * Fetch audio data from the sound card and process
   */
static gint app_stream_callback (App* self, void* input, void* output, gulong nframes, PaStreamCallbackTimeInfo* time, PaStreamCallbackFlags flags) {
	gint result = 0;
	gfloat* finput = NULL;
	gint finput_length1 = 0;
	gint _finput_size_ = 0;
	gulong _tmp0_;
	gint count;
	gint index;
	gint _tmp16_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (time != NULL, 0);
	_tmp0_ = nframes;
	count = (gint) _tmp0_;
	index = 0;
	while (TRUE) {
		gint _tmp1_;
		Config* _tmp2_;
		gint _tmp3_;
		void* _tmp4_;
		gint _tmp5_;
		Config* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gfloat* _tmp9_;
		gint _tmp9__length1;
		gint _tmp10_;
		Config* _tmp11_;
		gint _tmp12_;
		gint _tmp13_;
		Config* _tmp14_;
		gint _tmp15_;
		_tmp1_ = count;
		_tmp2_ = self->priv->config;
		_tmp3_ = _tmp2_->buffer_length;
		if (!(_tmp1_ > _tmp3_)) {
			break;
		}
		_tmp4_ = input;
		_tmp5_ = index;
		finput = (gfloat*) (&_tmp4_[_tmp5_]);
		finput_length1 = -1;
		_finput_size_ = finput_length1;
		_tmp6_ = self->priv->config;
		_tmp7_ = _tmp6_->buffer_length;
		finput_length1 = _tmp7_;
		_tmp8_ = finput_length1;
		_tmp9_ = finput;
		_tmp9__length1 = finput_length1;
		app_process_signal (self, _tmp9_, _tmp9__length1);
		_tmp10_ = count;
		_tmp11_ = self->priv->config;
		_tmp12_ = _tmp11_->buffer_length;
		count = _tmp10_ - _tmp12_;
		_tmp13_ = index;
		_tmp14_ = self->priv->config;
		_tmp15_ = _tmp14_->buffer_length;
		index = _tmp13_ + _tmp15_;
	}
	_tmp16_ = count;
	if (_tmp16_ > 0) {
		void* _tmp17_;
		gint _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		gfloat* _tmp21_;
		gint _tmp21__length1;
		_tmp17_ = input;
		_tmp18_ = index;
		finput = (gfloat*) (&_tmp17_[_tmp18_]);
		finput_length1 = -1;
		_finput_size_ = finput_length1;
		_tmp19_ = count;
		finput_length1 = _tmp19_;
		_tmp20_ = finput_length1;
		_tmp21_ = finput;
		_tmp21__length1 = finput_length1;
		app_process_signal (self, _tmp21_, _tmp21__length1);
	}
	result = 0;
	return result;
}


static gpointer _strobe_ref0 (gpointer self) {
	return self ? strobe_ref (self) : NULL;
}


static void app_process_signal (App* self, gfloat* input, int input_length1) {
	Converter* _tmp0_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	Strobe** _tmp2_;
	gint _tmp2__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->converter;
	_tmp1_ = input;
	_tmp1__length1 = input_length1;
	converter_process_signal (_tmp0_, _tmp1_, _tmp1__length1);
	_tmp2_ = self->priv->strobes;
	_tmp2__length1 = self->priv->strobes_length1;
	{
		Strobe** strobe_collection = NULL;
		gint strobe_collection_length1 = 0;
		gint _strobe_collection_size_ = 0;
		gint strobe_it = 0;
		strobe_collection = _tmp2_;
		strobe_collection_length1 = _tmp2__length1;
		for (strobe_it = 0; strobe_it < _tmp2__length1; strobe_it = strobe_it + 1) {
			Strobe* _tmp3_;
			Strobe* strobe = NULL;
			_tmp3_ = _strobe_ref0 (strobe_collection[strobe_it]);
			strobe = _tmp3_;
			{
				Strobe* _tmp4_;
				gfloat* _tmp5_;
				gint _tmp5__length1;
				_tmp4_ = strobe;
				_tmp5_ = input;
				_tmp5__length1 = input_length1;
				strobe_process_signal (_tmp4_, _tmp5_, _tmp5__length1);
				_strobe_unref0 (strobe);
			}
		}
	}
}


static gfloat app_find_peak (App* self, gfloat* buffer, int buffer_length1) {
	gfloat result = 0.0F;
	gfloat peak;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	g_return_val_if_fail (self != NULL, 0.0F);
	peak = 0.f;
	_tmp0_ = buffer;
	_tmp0__length1 = buffer_length1;
	{
		gfloat* sample_collection = NULL;
		gint sample_collection_length1 = 0;
		gint _sample_collection_size_ = 0;
		gint sample_it = 0;
		sample_collection = _tmp0_;
		sample_collection_length1 = _tmp0__length1;
		for (sample_it = 0; sample_it < _tmp0__length1; sample_it = sample_it + 1) {
			gfloat sample = 0.0F;
			sample = sample_collection[sample_it];
			{
				gfloat _tmp1_;
				gfloat _tmp2_;
				_tmp1_ = sample;
				_tmp2_ = peak;
				if (_tmp1_ < (-_tmp2_)) {
					gfloat _tmp3_;
					_tmp3_ = sample;
					peak = -_tmp3_;
				} else {
					gfloat _tmp4_;
					gfloat _tmp5_;
					_tmp4_ = sample;
					_tmp5_ = peak;
					if (_tmp4_ > _tmp5_) {
						gfloat _tmp6_;
						_tmp6_ = sample;
						peak = _tmp6_;
					}
				}
			}
		}
	}
	result = peak;
	return result;
}


static gdouble app_to_dbfs (gdouble value) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_ = 0.0;
	_tmp0_ = value;
	_tmp1_ = log10 (_tmp0_);
	result = 20.0 * _tmp1_;
	return result;
}


static gdouble app_from_dbfs (gdouble value) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_ = 0.0;
	_tmp0_ = value;
	_tmp1_ = pow ((gdouble) 10, _tmp0_ / 20.0);
	result = _tmp1_;
	return result;
}


void app_draw (App* self) {
	gboolean _tmp0_;
	Config* _tmp15_;
	gboolean _tmp16_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	display_window_background ((Display*) self);
	_tmp0_ = self->priv->instrument_mode;
	if (_tmp0_ == TRUE) {
		gfloat _tmp1_;
		Config* _tmp2_;
		gfloat* _tmp3_;
		gint _tmp3__length1;
		Config* _tmp4_;
		gfloat _tmp5_;
		Tuning12TETNote _tmp6_ = {0};
		_tmp1_ = self->priv->pitch;
		_tmp2_ = self->priv->config;
		_tmp3_ = _tmp2_->ins_notes;
		_tmp3__length1 = _tmp2_->ins_notes_length1;
		_tmp4_ = self->priv->config;
		_tmp5_ = _tmp4_->pitch_standard;
		tuning_12_tet_find_nearest (_tmp1_, _tmp3_, _tmp3__length1, _tmp5_, &_tmp6_);
		tuning_12_tet_note_destroy (&self->priv->note);
		self->priv->note = _tmp6_;
	} else {
		gfloat _tmp7_;
		Config* _tmp8_;
		gfloat _tmp9_;
		Config* _tmp10_;
		gfloat _tmp11_;
		Config* _tmp12_;
		gint _tmp13_;
		Tuning12TETNote _tmp14_ = {0};
		_tmp7_ = self->priv->pitch;
		_tmp8_ = self->priv->config;
		_tmp9_ = _tmp8_->pitch_standard;
		_tmp10_ = self->priv->config;
		_tmp11_ = _tmp10_->cents_offset;
		_tmp12_ = self->priv->config;
		_tmp13_ = _tmp12_->transpose;
		tuning_12_tet_find (_tmp7_, _tmp9_, _tmp11_, _tmp13_, &_tmp14_);
		tuning_12_tet_note_destroy (&self->priv->note);
		self->priv->note = _tmp14_;
	}
	_tmp15_ = self->priv->config;
	_tmp16_ = _tmp15_->display_flats;
	if (_tmp16_) {
		Tuning12TETNote _tmp17_;
		const gchar* _tmp18_;
		Tuning12TETNote _tmp19_;
		const gchar* _tmp20_;
		Tuning12TETNote _tmp21_;
		gint _tmp22_;
		gchar* _tmp23_ = NULL;
		gchar* _tmp24_;
		_tmp17_ = self->priv->note;
		_tmp18_ = _tmp17_.alt_letter;
		_tmp19_ = self->priv->note;
		_tmp20_ = _tmp19_.alt_sign;
		_tmp21_ = self->priv->note;
		_tmp22_ = _tmp21_.octave;
		_tmp23_ = g_strdup_printf ("%i", _tmp22_);
		_tmp24_ = _tmp23_;
		display_render_note ((Display*) self, _tmp18_, _tmp20_, _tmp24_);
		_g_free0 (_tmp24_);
	} else {
		Tuning12TETNote _tmp25_;
		const gchar* _tmp26_;
		Tuning12TETNote _tmp27_;
		const gchar* _tmp28_;
		Tuning12TETNote _tmp29_;
		gint _tmp30_;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_;
		_tmp25_ = self->priv->note;
		_tmp26_ = _tmp25_.letter;
		_tmp27_ = self->priv->note;
		_tmp28_ = _tmp27_.sign;
		_tmp29_ = self->priv->note;
		_tmp30_ = _tmp29_.octave;
		_tmp31_ = g_strdup_printf ("%i", _tmp30_);
		_tmp32_ = _tmp31_;
		display_render_note ((Display*) self, _tmp26_, _tmp28_, _tmp32_);
		_g_free0 (_tmp32_);
	}
	{
		DisplayStrobeSignal* _tmp33_;
		gint _tmp33__length1;
		_tmp33_ = self->priv->strobe_signals;
		_tmp33__length1 = self->priv->strobe_signals_length1;
		g_rec_mutex_lock (&self->priv->__lock_strobe_signals);
		{
			DisplayStrobeSignal* _tmp34_;
			gint _tmp34__length1;
			Config* _tmp35_;
			gfloat _tmp36_;
			Config* _tmp37_;
			RGB _tmp38_;
			Config* _tmp39_;
			RGB _tmp40_;
			_tmp34_ = self->priv->strobe_signals;
			_tmp34__length1 = self->priv->strobe_signals_length1;
			_tmp35_ = self->priv->config;
			_tmp36_ = _tmp35_->strobe_gain;
			_tmp37_ = self->priv->config;
			_tmp38_ = _tmp37_->strobe_background;
			_tmp39_ = self->priv->config;
			_tmp40_ = _tmp39_->strobe_foreground;
			display_strobe_display ((Display*) self, _tmp34_, _tmp34__length1, _tmp36_, &_tmp38_, &_tmp40_);
		}
		__finally0:
		{
			DisplayStrobeSignal* _tmp41_;
			gint _tmp41__length1;
			_tmp41_ = self->priv->strobe_signals;
			_tmp41__length1 = self->priv->strobe_signals_length1;
			g_rec_mutex_unlock (&self->priv->__lock_strobe_signals);
		}
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
}


gboolean app_above_threshold (App* self) {
	gboolean result = FALSE;
	gfloat _tmp0_;
	gfloat _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->peak;
	_tmp1_ = self->priv->threshold;
	result = _tmp0_ > _tmp1_;
	return result;
}


gint app_strobe (App* self) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		gint _tmp21_;
		{
			DisplayStrobeSignal* _tmp0_;
			gint _tmp0__length1;
			_tmp0_ = self->priv->strobe_signals;
			_tmp0__length1 = self->priv->strobe_signals_length1;
			g_rec_mutex_lock (&self->priv->__lock_strobe_signals);
			{
				{
					gint i;
					i = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							gboolean _tmp2_;
							gint _tmp4_;
							Strobe** _tmp5_;
							gint _tmp5__length1;
							Strobe** _tmp6_;
							gint _tmp6__length1;
							gint _tmp7_;
							Strobe* _tmp8_;
							DisplayStrobeSignal* _tmp9_;
							gint _tmp9__length1;
							gint _tmp10_;
							Strobe** _tmp11_;
							gint _tmp11__length1;
							gint _tmp12_;
							Strobe* _tmp13_;
							Tuning12TETNote _tmp14_;
							gfloat _tmp15_;
							Config* _tmp16_;
							gint* _tmp17_;
							gint _tmp17__length1;
							gint _tmp18_;
							gint _tmp19_;
							_tmp2_ = _tmp1_;
							if (!_tmp2_) {
								gint _tmp3_;
								_tmp3_ = i;
								i = _tmp3_ + 1;
							}
							_tmp1_ = FALSE;
							_tmp4_ = i;
							_tmp5_ = self->priv->strobes;
							_tmp5__length1 = self->priv->strobes_length1;
							if (!(_tmp4_ < _tmp5__length1)) {
								break;
							}
							_tmp6_ = self->priv->strobes;
							_tmp6__length1 = self->priv->strobes_length1;
							_tmp7_ = i;
							_tmp8_ = _tmp6_[_tmp7_];
							_tmp9_ = self->priv->strobe_signals;
							_tmp9__length1 = self->priv->strobe_signals_length1;
							_tmp10_ = i;
							strobe_read (_tmp8_, &_tmp9_[_tmp10_].data, &_tmp9_[_tmp10_].data_length1);
							_tmp11_ = self->priv->strobes;
							_tmp11__length1 = self->priv->strobes_length1;
							_tmp12_ = i;
							_tmp13_ = _tmp11_[_tmp12_];
							_tmp14_ = self->priv->note;
							_tmp15_ = _tmp14_.frequency;
							_tmp16_ = self->priv->config;
							_tmp17_ = _tmp16_->partials;
							_tmp17__length1 = _tmp16_->partials_length1;
							_tmp18_ = i;
							_tmp19_ = _tmp17_[_tmp18_];
							strobe_set_target_freq (_tmp13_, ((gfloat) _tmp15_) * _tmp19_);
						}
					}
				}
			}
			__finally1:
			{
				DisplayStrobeSignal* _tmp20_;
				gint _tmp20__length1;
				_tmp20_ = self->priv->strobe_signals;
				_tmp20__length1 = self->priv->strobe_signals_length1;
				g_rec_mutex_unlock (&self->priv->__lock_strobe_signals);
			}
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
		}
		_tmp21_ = self->priv->strobe_delay;
		g_usleep ((gulong) _tmp21_);
	}
	result = 0;
	return result;
	return result;
}


gint app_find_pitch (App* self) {
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		gboolean _tmp0_;
		gint _tmp12_;
		_tmp0_ = self->priv->manual_mode;
		if (_tmp0_ == FALSE) {
			{
				gfloat* _tmp1_;
				gint _tmp1__length1;
				_tmp1_ = self->priv->audio_signal;
				_tmp1__length1 = self->priv->audio_signal_length1;
				g_rec_mutex_lock (&self->priv->__lock_audio_signal);
				{
					Converter* _tmp2_;
					gfloat* _tmp3_;
					gint _tmp3__length1;
					gfloat _tmp4_ = 0.0F;
					gboolean _tmp5_ = FALSE;
					_tmp2_ = self->priv->converter;
					converter_read (_tmp2_, &self->priv->audio_signal, &self->priv->audio_signal_length1);
					_tmp3_ = self->priv->audio_signal;
					_tmp3__length1 = self->priv->audio_signal_length1;
					_tmp4_ = app_find_peak (self, _tmp3_, _tmp3__length1);
					self->priv->peak = _tmp4_;
					_tmp5_ = app_above_threshold (self);
					if (_tmp5_) {
						PitchEstimation* _tmp6_;
						gfloat* _tmp7_;
						gint _tmp7__length1;
						gfloat _tmp8_ = 0.0F;
						gfloat p;
						gfloat _tmp9_;
						gfloat _tmp10_ = 0.0F;
						_tmp6_ = self->priv->pitch_estimation;
						_tmp7_ = self->priv->audio_signal;
						_tmp7__length1 = self->priv->audio_signal_length1;
						_tmp8_ = pitch_estimation_pitch_from_autocorrelation (_tmp6_, _tmp7_, _tmp7__length1);
						p = _tmp8_;
						_tmp9_ = p;
						_tmp10_ = CLAMP (_tmp9_, 27.5000f, 4186.01f);
						self->priv->pitch = _tmp10_;
					}
				}
				__finally2:
				{
					gfloat* _tmp11_;
					gint _tmp11__length1;
					_tmp11_ = self->priv->audio_signal;
					_tmp11__length1 = self->priv->audio_signal_length1;
					g_rec_mutex_unlock (&self->priv->__lock_audio_signal);
				}
				if (_inner_error_ != NULL) {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
			}
		}
		_tmp12_ = self->priv->estimation_delay;
		g_usleep ((gulong) _tmp12_);
	}
	result = 0;
	return result;
	return result;
}


static gpointer _app_find_pitch_gthread_func (gpointer self) {
	gpointer result;
	result = app_find_pitch (self);
	return result;
}


static gpointer _app_strobe_gthread_func (gpointer self) {
	gpointer result;
	result = app_strobe (self);
	return result;
}


gint app_main (gchar** args, int args_length1) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	App* _tmp2_;
	App* app;
	App* _tmp3_;
	GThread* _tmp4_;
	GThread* thread_a;
	App* _tmp5_;
	GThread* _tmp6_;
	GThread* thread_b;
	_tmp0_ = g_thread_supported ();
	if (!_tmp0_) {
		FILE* _tmp1_;
		_tmp1_ = stderr;
		fprintf (_tmp1_, "Cannot run without thread support.\n");
		result = 1;
		return result;
	}
	_tmp2_ = app_new ();
	app = _tmp2_;
	_tmp3_ = app;
	_tmp4_ = g_thread_new ("a", _app_find_pitch_gthread_func, gl_cairo_window_ref (_tmp3_));
	thread_a = _tmp4_;
	_tmp5_ = app;
	_tmp6_ = g_thread_new ("b", _app_strobe_gthread_func, gl_cairo_window_ref (_tmp5_));
	thread_b = _tmp6_;
	while (TRUE) {
		App* _tmp7_;
		gboolean _tmp8_;
		App* _tmp9_;
		App* _tmp10_;
		_tmp7_ = app;
		_tmp8_ = ((GLCairoWindow*) _tmp7_)->quit;
		if (!(!_tmp8_)) {
			break;
		}
		_tmp9_ = app;
		app_draw (_tmp9_);
		_tmp10_ = app;
		gl_cairo_window_process_events ((GLCairoWindow*) _tmp10_);
		g_usleep ((gulong) 10000);
	}
	result = 0;
	_g_thread_unref0 (thread_b);
	_g_thread_unref0 (thread_a);
	_gl_cairo_window_unref0 (app);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return app_main (argv, argc);
}


static void app_class_init (AppClass * klass) {
	app_parent_class = g_type_class_peek_parent (klass);
	GL_CAIRO_WINDOW_CLASS (klass)->finalize = app_finalize;
	g_type_class_add_private (klass, sizeof (AppPrivate));
}


static void app_instance_init (App * self) {
	self->priv = APP_GET_PRIVATE (self);
	self->priv->pitch = 27.5000f;
	g_rec_mutex_init (&self->priv->__lock_audio_signal);
	g_rec_mutex_init (&self->priv->__lock_strobe_signals);
	self->priv->above = FALSE;
	self->priv->manual_mode = FALSE;
	self->priv->instrument_mode = FALSE;
}


static void app_finalize (GLCairoWindow* obj) {
	App * self;
	PaStream* _tmp0_;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_APP, App);
	_tmp0_ = self->priv->stream;
	Pa_StopStream (_tmp0_);
	_config_unref0 (self->priv->config);
	_converter_unref0 (self->priv->converter);
	_pitch_estimation_unref0 (self->priv->pitch_estimation);
	_Pa_CloseStream0 (self->priv->stream);
	tuning_12_tet_note_destroy (&self->priv->note);
	g_rec_mutex_clear (&self->priv->__lock_audio_signal);
	self->priv->audio_signal = (g_free (self->priv->audio_signal), NULL);
	self->priv->strobes = (_vala_array_free (self->priv->strobes, self->priv->strobes_length1, (GDestroyNotify) strobe_unref), NULL);
	g_rec_mutex_clear (&self->priv->__lock_strobe_signals);
	self->priv->strobe_signals = (_vala_DisplayStrobeSignal_array_free (self->priv->strobe_signals, self->priv->strobe_signals_length1), NULL);
	GL_CAIRO_WINDOW_CLASS (app_parent_class)->finalize (obj);
}


GType app_get_type (void) {
	static volatile gsize app_type_id__volatile = 0;
	if (g_once_init_enter (&app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (App), 0, (GInstanceInitFunc) app_instance_init, NULL };
		GType app_type_id;
		app_type_id = g_type_register_static (TYPE_DISPLAY, "App", &g_define_type_info, 0);
		g_once_init_leave (&app_type_id__volatile, app_type_id);
	}
	return app_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



