/* config.c generated by valac 0.18.1, the Vala compiler
 * generated from config.vala, do not modify */

/*
  Copyright (C) 2013 Davorin Å ego
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <json-glib/json-glib.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_CONFIG (config_get_type ())
#define CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG, Config))
#define CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG, ConfigClass))
#define IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG))
#define IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG))
#define CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG, ConfigClass))

typedef struct _Config Config;
typedef struct _ConfigClass ConfigClass;
typedef struct _ConfigPrivate ConfigPrivate;

#define TYPE_RGB (rgb_get_type ())
typedef struct _RGB RGB;
#define __vala_JsonObject_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonObject_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _ParamSpecConfig ParamSpecConfig;

struct _RGB {
	gfloat r;
	gfloat g;
	gfloat b;
};

struct _Config {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ConfigPrivate * priv;
	gint sample_rate;
	gint fft_sample_rate;
	gint fft_length;
	gint buffer_length;
	gint resampled_buffer_length;
	gint periods_per_frame;
	gint estimation_framerate;
	gint strobe_framerate;
	gfloat audio_threshold;
	gfloat strobe_gain;
	gfloat pitch_standard;
	gboolean display_flats;
	gint transpose;
	gfloat cents_offset;
	gint* partials;
	gint partials_length1;
	gint* samples_per_period;
	gint samples_per_period_length1;
	gfloat* ins_notes;
	gint ins_notes_length1;
	RGB strobe_background;
	RGB strobe_foreground;
};

struct _ConfigClass {
	GTypeClass parent_class;
	void (*finalize) (Config *self);
};

struct _ParamSpecConfig {
	GParamSpec parent_instance;
};


static gpointer config_parent_class = NULL;

gpointer config_ref (gpointer instance);
void config_unref (gpointer instance);
GParamSpec* param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_config (GValue* value, gpointer v_object);
void value_take_config (GValue* value, gpointer v_object);
gpointer value_get_config (const GValue* value);
GType config_get_type (void) G_GNUC_CONST;
GType rgb_get_type (void) G_GNUC_CONST;
RGB* rgb_dup (const RGB* self);
void rgb_free (RGB* self);
enum  {
	CONFIG_DUMMY_PROPERTY
};
void rgb_init (RGB *self, gfloat r, gfloat g, gfloat b);
Config* config_new (const gchar* filename);
Config* config_construct (GType object_type, const gchar* filename);
static JsonObject* config_parse_config_file (Config* self, const gchar* filename);
static void config_load_from_json (Config* self, JsonObject* json_object);
static void _vala_JsonObject_free (JsonObject* self);
static void config_read_int_array (JsonArray* json_array, gint** array, int* array_length1);
static void config_read_float_array (JsonArray* json_array, gfloat** array, int* array_length1);
static void config_parse_from_hex (const gchar* hex, RGB* result);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);
static void _vala_JsonNode_free (JsonNode* self);
static JsonObject* _vala_JsonObject_copy (JsonObject* self);
static void config_finalize (Config* obj);


static void _vala_JsonObject_free (JsonObject* self) {
	g_boxed_free (json_object_get_type (), self);
}


Config* config_construct (GType object_type, const gchar* filename) {
	Config* self = NULL;
	const gchar* _tmp0_;
	JsonObject* _tmp1_ = NULL;
	JsonObject* json_config;
	JsonObject* _tmp2_;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (Config*) g_type_create_instance (object_type);
	_tmp0_ = filename;
	_tmp1_ = config_parse_config_file (self, _tmp0_);
	json_config = _tmp1_;
	_tmp2_ = json_config;
	if (_tmp2_ != NULL) {
		JsonObject* _tmp3_;
		_tmp3_ = json_config;
		config_load_from_json (self, _tmp3_);
	}
	__vala_JsonObject_free0 (json_config);
	return self;
}


Config* config_new (const gchar* filename) {
	return config_construct (TYPE_CONFIG, filename);
}


static void config_load_from_json (Config* self, JsonObject* json_object) {
	JsonObject* _tmp0_;
	gboolean _tmp1_ = FALSE;
	JsonObject* _tmp4_;
	gboolean _tmp5_ = FALSE;
	JsonObject* _tmp8_;
	gboolean _tmp9_ = FALSE;
	JsonObject* _tmp12_;
	gboolean _tmp13_ = FALSE;
	JsonObject* _tmp16_;
	gboolean _tmp17_ = FALSE;
	JsonObject* _tmp20_;
	gboolean _tmp21_ = FALSE;
	JsonObject* _tmp24_;
	gboolean _tmp25_ = FALSE;
	JsonObject* _tmp28_;
	gboolean _tmp29_ = FALSE;
	JsonObject* _tmp32_;
	gboolean _tmp33_ = FALSE;
	JsonObject* _tmp36_;
	gboolean _tmp37_ = FALSE;
	JsonObject* _tmp40_;
	gboolean _tmp41_ = FALSE;
	JsonObject* _tmp44_;
	gboolean _tmp45_ = FALSE;
	JsonObject* _tmp48_;
	gboolean _tmp49_ = FALSE;
	JsonObject* _tmp52_;
	gboolean _tmp53_ = FALSE;
	JsonObject* _tmp56_;
	gboolean _tmp57_ = FALSE;
	JsonObject* _tmp60_;
	gboolean _tmp61_ = FALSE;
	JsonObject* _tmp64_;
	gboolean _tmp65_ = FALSE;
	JsonObject* _tmp68_;
	gboolean _tmp69_ = FALSE;
	JsonObject* _tmp73_;
	gboolean _tmp74_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (json_object != NULL);
	_tmp0_ = json_object;
	_tmp1_ = json_object_has_member (_tmp0_, "sample_rate");
	if (_tmp1_) {
		JsonObject* _tmp2_;
		gint64 _tmp3_ = 0LL;
		_tmp2_ = json_object;
		_tmp3_ = json_object_get_int_member (_tmp2_, "sample_rate");
		self->sample_rate = (gint) _tmp3_;
	}
	_tmp4_ = json_object;
	_tmp5_ = json_object_has_member (_tmp4_, "fft_sample_rate");
	if (_tmp5_) {
		JsonObject* _tmp6_;
		gint64 _tmp7_ = 0LL;
		_tmp6_ = json_object;
		_tmp7_ = json_object_get_int_member (_tmp6_, "fft_sample_rate");
		self->fft_sample_rate = (gint) _tmp7_;
	}
	_tmp8_ = json_object;
	_tmp9_ = json_object_has_member (_tmp8_, "fft_length");
	if (_tmp9_) {
		JsonObject* _tmp10_;
		gint64 _tmp11_ = 0LL;
		_tmp10_ = json_object;
		_tmp11_ = json_object_get_int_member (_tmp10_, "fft_length");
		self->fft_length = (gint) _tmp11_;
	}
	_tmp12_ = json_object;
	_tmp13_ = json_object_has_member (_tmp12_, "buffer_length");
	if (_tmp13_) {
		JsonObject* _tmp14_;
		gint64 _tmp15_ = 0LL;
		_tmp14_ = json_object;
		_tmp15_ = json_object_get_int_member (_tmp14_, "buffer_length");
		self->buffer_length = (gint) _tmp15_;
	}
	_tmp16_ = json_object;
	_tmp17_ = json_object_has_member (_tmp16_, "resampled_buffer_length");
	if (_tmp17_) {
		JsonObject* _tmp18_;
		gint64 _tmp19_ = 0LL;
		_tmp18_ = json_object;
		_tmp19_ = json_object_get_int_member (_tmp18_, "resampled_buffer_length");
		self->resampled_buffer_length = (gint) _tmp19_;
	}
	_tmp20_ = json_object;
	_tmp21_ = json_object_has_member (_tmp20_, "periods_per_frame");
	if (_tmp21_) {
		JsonObject* _tmp22_;
		gint64 _tmp23_ = 0LL;
		_tmp22_ = json_object;
		_tmp23_ = json_object_get_int_member (_tmp22_, "periods_per_frame");
		self->periods_per_frame = (gint) _tmp23_;
	}
	_tmp24_ = json_object;
	_tmp25_ = json_object_has_member (_tmp24_, "estimation_framerate");
	if (_tmp25_) {
		JsonObject* _tmp26_;
		gint64 _tmp27_ = 0LL;
		_tmp26_ = json_object;
		_tmp27_ = json_object_get_int_member (_tmp26_, "estimation_framerate");
		self->estimation_framerate = (gint) _tmp27_;
	}
	_tmp28_ = json_object;
	_tmp29_ = json_object_has_member (_tmp28_, "strobe_framerate");
	if (_tmp29_) {
		JsonObject* _tmp30_;
		gint64 _tmp31_ = 0LL;
		_tmp30_ = json_object;
		_tmp31_ = json_object_get_int_member (_tmp30_, "strobe_framerate");
		self->strobe_framerate = (gint) _tmp31_;
	}
	_tmp32_ = json_object;
	_tmp33_ = json_object_has_member (_tmp32_, "audio_threshold");
	if (_tmp33_) {
		JsonObject* _tmp34_;
		gdouble _tmp35_ = 0.0;
		_tmp34_ = json_object;
		_tmp35_ = json_object_get_double_member (_tmp34_, "audio_threshold");
		self->audio_threshold = (gfloat) _tmp35_;
	}
	_tmp36_ = json_object;
	_tmp37_ = json_object_has_member (_tmp36_, "strobe_gain");
	if (_tmp37_) {
		JsonObject* _tmp38_;
		gdouble _tmp39_ = 0.0;
		_tmp38_ = json_object;
		_tmp39_ = json_object_get_double_member (_tmp38_, "strobe_gain");
		self->strobe_gain = (gfloat) _tmp39_;
	}
	_tmp40_ = json_object;
	_tmp41_ = json_object_has_member (_tmp40_, "pitch_standard");
	if (_tmp41_) {
		JsonObject* _tmp42_;
		gdouble _tmp43_ = 0.0;
		_tmp42_ = json_object;
		_tmp43_ = json_object_get_double_member (_tmp42_, "pitch_standard");
		self->pitch_standard = (gfloat) _tmp43_;
	}
	_tmp44_ = json_object;
	_tmp45_ = json_object_has_member (_tmp44_, "display_flats");
	if (_tmp45_) {
		JsonObject* _tmp46_;
		gboolean _tmp47_ = FALSE;
		_tmp46_ = json_object;
		_tmp47_ = json_object_get_boolean_member (_tmp46_, "display_flats");
		self->display_flats = _tmp47_;
	}
	_tmp48_ = json_object;
	_tmp49_ = json_object_has_member (_tmp48_, "transpose");
	if (_tmp49_) {
		JsonObject* _tmp50_;
		gint64 _tmp51_ = 0LL;
		_tmp50_ = json_object;
		_tmp51_ = json_object_get_int_member (_tmp50_, "transpose");
		self->transpose = (gint) _tmp51_;
	}
	_tmp52_ = json_object;
	_tmp53_ = json_object_has_member (_tmp52_, "cents_offset");
	if (_tmp53_) {
		JsonObject* _tmp54_;
		gdouble _tmp55_ = 0.0;
		_tmp54_ = json_object;
		_tmp55_ = json_object_get_double_member (_tmp54_, "cents_offset");
		self->cents_offset = (gfloat) _tmp55_;
	}
	_tmp56_ = json_object;
	_tmp57_ = json_object_has_member (_tmp56_, "partials");
	if (_tmp57_) {
		JsonObject* _tmp58_;
		JsonArray* _tmp59_ = NULL;
		_tmp58_ = json_object;
		_tmp59_ = json_object_get_array_member (_tmp58_, "partials");
		config_read_int_array (_tmp59_, &self->partials, &self->partials_length1);
	}
	_tmp60_ = json_object;
	_tmp61_ = json_object_has_member (_tmp60_, "samples_per_period");
	if (_tmp61_) {
		JsonObject* _tmp62_;
		JsonArray* _tmp63_ = NULL;
		_tmp62_ = json_object;
		_tmp63_ = json_object_get_array_member (_tmp62_, "samples_per_period");
		config_read_int_array (_tmp63_, &self->samples_per_period, &self->samples_per_period_length1);
	}
	_tmp64_ = json_object;
	_tmp65_ = json_object_has_member (_tmp64_, "ins_notes     ");
	if (_tmp65_) {
		JsonObject* _tmp66_;
		JsonArray* _tmp67_ = NULL;
		_tmp66_ = json_object;
		_tmp67_ = json_object_get_array_member (_tmp66_, "ins_notes     ");
		config_read_float_array (_tmp67_, &self->ins_notes, &self->ins_notes_length1);
	}
	_tmp68_ = json_object;
	_tmp69_ = json_object_has_member (_tmp68_, "strobe_background");
	if (_tmp69_) {
		JsonObject* _tmp70_;
		const gchar* _tmp71_ = NULL;
		RGB _tmp72_ = {0};
		_tmp70_ = json_object;
		_tmp71_ = json_object_get_string_member (_tmp70_, "strobe_background");
		config_parse_from_hex (_tmp71_, &_tmp72_);
		self->strobe_background = _tmp72_;
	}
	_tmp73_ = json_object;
	_tmp74_ = json_object_has_member (_tmp73_, "strobe_foreground");
	if (_tmp74_) {
		JsonObject* _tmp75_;
		const gchar* _tmp76_ = NULL;
		RGB _tmp77_ = {0};
		_tmp75_ = json_object;
		_tmp76_ = json_object_get_string_member (_tmp75_, "strobe_foreground");
		config_parse_from_hex (_tmp76_, &_tmp77_);
		self->strobe_foreground = _tmp77_;
	}
}


static JsonNode* _vala_JsonNode_copy (JsonNode* self) {
	return g_boxed_copy (json_node_get_type (), self);
}


static gpointer __vala_JsonNode_copy0 (gpointer self) {
	return self ? _vala_JsonNode_copy (self) : NULL;
}


static void _vala_JsonNode_free (JsonNode* self) {
	g_boxed_free (json_node_get_type (), self);
}


static JsonObject* _vala_JsonObject_copy (JsonObject* self) {
	return g_boxed_copy (json_object_get_type (), self);
}


static gpointer __vala_JsonObject_copy0 (gpointer self) {
	return self ? _vala_JsonObject_copy (self) : NULL;
}


static JsonObject* config_parse_config_file (Config* self, const gchar* filename) {
	JsonObject* result = NULL;
	JsonParser* _tmp0_;
	JsonParser* parser;
	gboolean file_parsed;
	gboolean _tmp8_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = json_parser_new ();
	parser = _tmp0_;
	file_parsed = FALSE;
	{
		JsonParser* _tmp1_;
		const gchar* _tmp2_;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_;
		_tmp1_ = parser;
		_tmp2_ = filename;
		_tmp3_ = json_parser_load_from_file (_tmp1_, _tmp2_, &_inner_error_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
		file_parsed = _tmp4_;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_;
		GError* _tmp6_;
		const gchar* _tmp7_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stderr;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "%s\n", _tmp7_);
		result = NULL;
		_g_error_free0 (e);
		_g_object_unref0 (parser);
		return result;
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (parser);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp8_ = file_parsed;
	if (_tmp8_) {
		JsonParser* _tmp9_;
		JsonNode* _tmp10_ = NULL;
		JsonNode* _tmp11_;
		JsonNode* root;
		JsonNode* _tmp12_;
		JsonNode* _tmp14_;
		JsonObject* _tmp15_ = NULL;
		JsonObject* _tmp16_;
		_tmp9_ = parser;
		_tmp10_ = json_parser_get_root (_tmp9_);
		_tmp11_ = __vala_JsonNode_copy0 (_tmp10_);
		root = _tmp11_;
		_tmp12_ = root;
		if (_tmp12_ == NULL) {
			FILE* _tmp13_;
			_tmp13_ = stderr;
			fprintf (_tmp13_, "Configuration file missing root object.\n");
			result = NULL;
			__vala_JsonNode_free0 (root);
			_g_object_unref0 (parser);
			return result;
		}
		_tmp14_ = root;
		_tmp15_ = json_node_get_object (_tmp14_);
		_tmp16_ = __vala_JsonObject_copy0 (_tmp15_);
		result = _tmp16_;
		__vala_JsonNode_free0 (root);
		_g_object_unref0 (parser);
		return result;
	}
	result = NULL;
	_g_object_unref0 (parser);
	return result;
}


static void config_read_int_array (JsonArray* json_array, gint** array, int* array_length1) {
	JsonArray* _tmp0_;
	guint _tmp1_ = 0U;
	guint len;
	guint _tmp2_;
	gint* _tmp3_ = NULL;
	g_return_if_fail (json_array != NULL);
	_tmp0_ = json_array;
	_tmp1_ = json_array_get_length (_tmp0_);
	len = _tmp1_;
	_tmp2_ = len;
	_tmp3_ = g_new0 (gint, _tmp2_);
	*array = (g_free (*array), NULL);
	*array = _tmp3_;
	*array_length1 = _tmp2_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				guint _tmp8_;
				gint* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				JsonArray* _tmp11_;
				gint _tmp12_;
				gint64 _tmp13_ = 0LL;
				gint _tmp14_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = len;
				if (!(((guint) _tmp7_) < _tmp8_)) {
					break;
				}
				_tmp9_ = *array;
				_tmp9__length1 = *array_length1;
				_tmp10_ = i;
				_tmp11_ = json_array;
				_tmp12_ = i;
				_tmp13_ = json_array_get_int_element (_tmp11_, (guint) _tmp12_);
				_tmp9_[_tmp10_] = (gint) _tmp13_;
				_tmp14_ = _tmp9_[_tmp10_];
			}
		}
	}
}


static void config_read_float_array (JsonArray* json_array, gfloat** array, int* array_length1) {
	JsonArray* _tmp0_;
	guint _tmp1_ = 0U;
	guint len;
	guint _tmp2_;
	gfloat* _tmp3_ = NULL;
	g_return_if_fail (json_array != NULL);
	_tmp0_ = json_array;
	_tmp1_ = json_array_get_length (_tmp0_);
	len = _tmp1_;
	_tmp2_ = len;
	_tmp3_ = g_new0 (gfloat, _tmp2_);
	*array = (g_free (*array), NULL);
	*array = _tmp3_;
	*array_length1 = _tmp2_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				gint _tmp7_;
				guint _tmp8_;
				gfloat* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				JsonArray* _tmp11_;
				gint _tmp12_;
				gdouble _tmp13_ = 0.0;
				gfloat _tmp14_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = len;
				if (!(((guint) _tmp7_) < _tmp8_)) {
					break;
				}
				_tmp9_ = *array;
				_tmp9__length1 = *array_length1;
				_tmp10_ = i;
				_tmp11_ = json_array;
				_tmp12_ = i;
				_tmp13_ = json_array_get_double_element (_tmp11_, (guint) _tmp12_);
				_tmp9_[_tmp10_] = (gfloat) _tmp13_;
				_tmp14_ = _tmp9_[_tmp10_];
			}
		}
	}
}


static void config_parse_from_hex (const gchar* hex, RGB* result) {
	gint r;
	gint g;
	gint b;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	RGB _tmp21_ = {0};
	g_return_if_fail (hex != NULL);
	r = 1;
	g = 1;
	b = 1;
	_tmp0_ = hex;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 4) {
		const gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		_tmp3_ = hex;
		_tmp4_ = g_utf8_strdown (_tmp3_, (gssize) (-1));
		_tmp5_ = _tmp4_;
		sscanf (_tmp5_, "#%1x%1x%1x", &r, &g, &b);
		_g_free0 (_tmp5_);
		_tmp6_ = r;
		_tmp7_ = r;
		r = (_tmp6_ * 16) + _tmp7_;
		_tmp8_ = g;
		_tmp9_ = g;
		g = (_tmp8_ * 16) + _tmp9_;
		_tmp10_ = b;
		_tmp11_ = b;
		b = (_tmp10_ * 16) + _tmp11_;
	} else {
		const gchar* _tmp12_;
		gint _tmp13_;
		gint _tmp14_;
		_tmp12_ = hex;
		_tmp13_ = strlen (_tmp12_);
		_tmp14_ = _tmp13_;
		if (_tmp14_ == 7) {
			const gchar* _tmp15_;
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_;
			_tmp15_ = hex;
			_tmp16_ = g_utf8_strdown (_tmp15_, (gssize) (-1));
			_tmp17_ = _tmp16_;
			sscanf (_tmp17_, "#%2x%2x%2x", &r, &g, &b);
			_g_free0 (_tmp17_);
		}
	}
	_tmp18_ = r;
	_tmp19_ = g;
	_tmp20_ = b;
	rgb_init (&_tmp21_, _tmp18_ / 255.f, _tmp19_ / 255.f, _tmp20_ / 255.f);
	*result = _tmp21_;
	return;
}


static void value_config_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_config_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		config_unref (value->data[0].v_pointer);
	}
}


static void value_config_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = config_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_config_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_config_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Config* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = config_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_config_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Config** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = config_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecConfig* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_CONFIG), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_config (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONFIG), NULL);
	return value->data[0].v_pointer;
}


void value_set_config (GValue* value, gpointer v_object) {
	Config* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		config_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		config_unref (old);
	}
}


void value_take_config (GValue* value, gpointer v_object) {
	Config* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		config_unref (old);
	}
}


static void config_class_init (ConfigClass * klass) {
	config_parent_class = g_type_class_peek_parent (klass);
	CONFIG_CLASS (klass)->finalize = config_finalize;
}


static void config_instance_init (Config * self) {
	gint* _tmp0_ = NULL;
	gint* _tmp1_ = NULL;
	gfloat* _tmp2_ = NULL;
	RGB _tmp3_ = {0};
	RGB _tmp4_ = {0};
	self->sample_rate = 44100;
	self->fft_sample_rate = 44100;
	self->fft_length = 4096;
	self->buffer_length = 512;
	self->resampled_buffer_length = 512 * 25;
	self->periods_per_frame = 1;
	self->estimation_framerate = 20;
	self->strobe_framerate = 60;
	self->audio_threshold = (gfloat) (-40);
	self->strobe_gain = 1000.f;
	self->pitch_standard = 440.0f;
	self->display_flats = FALSE;
	self->transpose = 0;
	self->cents_offset = 0.f;
	_tmp0_ = g_new0 (gint, 3);
	_tmp0_[0] = 4;
	_tmp0_[1] = 2;
	_tmp0_[2] = 1;
	self->partials = _tmp0_;
	self->partials_length1 = 3;
	_tmp1_ = g_new0 (gint, 3);
	_tmp1_[0] = 64;
	_tmp1_[1] = 128;
	_tmp1_[2] = 256;
	self->samples_per_period = _tmp1_;
	self->samples_per_period_length1 = 3;
	_tmp2_ = g_new0 (gfloat, 6);
	_tmp2_[0] = -2900.f;
	_tmp2_[1] = -2400.f;
	_tmp2_[2] = -1900.f;
	_tmp2_[3] = -1400.f;
	_tmp2_[4] = -1000.f;
	_tmp2_[5] = -500.f;
	self->ins_notes = _tmp2_;
	self->ins_notes_length1 = 6;
	rgb_init (&_tmp3_, 0.157f, 0.110f, 0.055f);
	self->strobe_background = _tmp3_;
	rgb_init (&_tmp4_, 0.984f, 0.627f, 0.106f);
	self->strobe_foreground = _tmp4_;
	self->ref_count = 1;
}


static void config_finalize (Config* obj) {
	Config * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CONFIG, Config);
	self->partials = (g_free (self->partials), NULL);
	self->samples_per_period = (g_free (self->samples_per_period), NULL);
	self->ins_notes = (g_free (self->ins_notes), NULL);
}


GType config_get_type (void) {
	static volatile gsize config_type_id__volatile = 0;
	if (g_once_init_enter (&config_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_config_init, value_config_free_value, value_config_copy_value, value_config_peek_pointer, "p", value_config_collect_value, "p", value_config_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Config), 0, (GInstanceInitFunc) config_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType config_type_id;
		config_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Config", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&config_type_id__volatile, config_type_id);
	}
	return config_type_id__volatile;
}


gpointer config_ref (gpointer instance) {
	Config* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void config_unref (gpointer instance) {
	Config* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CONFIG_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



