/* src.c generated by valac 0.18.1, the Vala compiler
 * generated from src.vala, do not modify */

/*
  Copyright (C) 2012 Davorin Å ego

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  of the Software, and to permit persons to whom the Software is furnished to do
  so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SRC (src_get_type ())
#define SRC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SRC, SRC))
#define SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SRC, SRCClass))
#define IS_SRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SRC))
#define IS_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SRC))
#define SRC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SRC, SRCClass))

typedef struct _SRC SRC;
typedef struct _SRCClass SRCClass;
typedef struct _SRCPrivate SRCPrivate;
typedef struct _ParamSpecSRC ParamSpecSRC;

struct _SRC {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SRCPrivate * priv;
	gdouble ratio;
	gdouble interval;
	gdouble rem;
	gdouble rems[32];
	gdouble t;
	gint in_i;
	gint out_i;
	gdouble time;
};

struct _SRCClass {
	GTypeClass parent_class;
	void (*finalize) (SRC *self);
};

struct _ParamSpecSRC {
	GParamSpec parent_instance;
};


static gpointer src_parent_class = NULL;

gpointer src_ref (gpointer instance);
void src_unref (gpointer instance);
GParamSpec* param_spec_src (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_src (GValue* value, gpointer v_object);
void value_take_src (GValue* value, gpointer v_object);
gpointer value_get_src (const GValue* value);
GType src_get_type (void) G_GNUC_CONST;
enum  {
	SRC_DUMMY_PROPERTY
};
SRC* src_new (gdouble out_rate, gdouble in_rate);
SRC* src_construct (GType object_type, gdouble out_rate, gdouble in_rate);
void src_set_ratio (SRC* self, gdouble out_rate, gdouble in_rate);
void src_reset (SRC* self);
gint src_linear_convert (SRC* self, gfloat* in, int in_length1, gfloat* out, int out_length1);
void src_reset_indices (SRC* self);
gdouble src_linear (SRC* self, gdouble y0, gdouble y1, gdouble t);
void src_increment_time (SRC* self);
gint src_cubic_convert (SRC* self, gfloat* in, int in_length1, gfloat* out, int out_length1);
gdouble src_cubic (SRC* self, gdouble y0, gdouble y1, gdouble y2, gdouble y3, gdouble t);
static void src_finalize (SRC* obj);


SRC* src_construct (GType object_type, gdouble out_rate, gdouble in_rate) {
	SRC* self = NULL;
	gdouble _tmp0_;
	gdouble _tmp1_;
	self = (SRC*) g_type_create_instance (object_type);
	_tmp0_ = out_rate;
	_tmp1_ = in_rate;
	src_set_ratio (self, _tmp0_, _tmp1_);
	return self;
}


SRC* src_new (gdouble out_rate, gdouble in_rate) {
	return src_construct (TYPE_SRC, out_rate, in_rate);
}


void src_set_ratio (SRC* self, gdouble out_rate, gdouble in_rate) {
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = out_rate;
	_tmp1_ = in_rate;
	self->ratio = _tmp0_ / _tmp1_;
	_tmp2_ = self->ratio;
	self->interval = 1 / _tmp2_;
}


void src_reset (SRC* self) {
	gdouble _tmp0_[32] = {0};
	g_return_if_fail (self != NULL);
	self->rem = (gdouble) 0;
	_tmp0_[0] = (gdouble) 0;
	_tmp0_[1] = (gdouble) 0;
	_tmp0_[2] = (gdouble) 0;
	memcpy (self->rems, _tmp0_, 32 * sizeof (gdouble));
	self->time = (gdouble) 0;
}


/**
   * Convert a chunk of data - linear interpolation.
   * Returns the number of generated samples.
   */
gint src_linear_convert (SRC* self, gfloat* in, int in_length1, gfloat* out, int out_length1) {
	gint result = 0;
	gdouble _tmp0_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat* _tmp19_;
	gint _tmp19__length1;
	gint last;
	gfloat* _tmp33_;
	gint _tmp33__length1;
	gint _tmp34_;
	gfloat _tmp35_;
	gdouble _tmp36_;
	gint _tmp37_;
	gint _tmp38_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->ratio;
	_tmp1_ = in;
	_tmp1__length1 = in_length1;
	_tmp2_ = out;
	_tmp2__length1 = out_length1;
	if (((gint) (_tmp0_ * _tmp1__length1)) > _tmp2__length1) {
		FILE* _tmp3_;
		gdouble _tmp4_;
		gfloat* _tmp5_;
		gint _tmp5__length1;
		gfloat* _tmp6_;
		gint _tmp6__length1;
		_tmp3_ = stderr;
		_tmp4_ = self->ratio;
		_tmp5_ = in;
		_tmp5__length1 = in_length1;
		_tmp6_ = out;
		_tmp6__length1 = out_length1;
		fprintf (_tmp3_, "Output buffer is too small (need %i, buffer size %i).\n", (gint) (_tmp4_ * _tmp5__length1), _tmp6__length1);
		result = 0;
		return result;
	}
	src_reset_indices (self);
	while (TRUE) {
		gboolean _tmp7_ = FALSE;
		gdouble _tmp8_;
		gboolean _tmp10_;
		gfloat* _tmp11_;
		gint _tmp11__length1;
		gint _tmp12_;
		gdouble _tmp13_;
		gfloat* _tmp14_;
		gint _tmp14__length1;
		gfloat _tmp15_;
		gdouble _tmp16_;
		gdouble _tmp17_ = 0.0;
		gfloat _tmp18_;
		_tmp8_ = self->time;
		if (_tmp8_ < ((gdouble) 0)) {
			gfloat* _tmp9_;
			gint _tmp9__length1;
			_tmp9_ = in;
			_tmp9__length1 = in_length1;
			_tmp7_ = _tmp9__length1 >= 1;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp10_ = _tmp7_;
		if (!_tmp10_) {
			break;
		}
		_tmp11_ = out;
		_tmp11__length1 = out_length1;
		_tmp12_ = self->out_i;
		_tmp13_ = self->rem;
		_tmp14_ = in;
		_tmp14__length1 = in_length1;
		_tmp15_ = _tmp14_[0];
		_tmp16_ = self->time;
		_tmp17_ = src_linear (self, _tmp13_, (gdouble) _tmp15_, _tmp16_ + 1);
		_tmp11_[_tmp12_] = (gfloat) _tmp17_;
		_tmp18_ = _tmp11_[_tmp12_];
		src_increment_time (self);
	}
	_tmp19_ = in;
	_tmp19__length1 = in_length1;
	last = _tmp19__length1 - 1;
	while (TRUE) {
		gint _tmp20_;
		gint _tmp21_;
		gfloat* _tmp22_;
		gint _tmp22__length1;
		gint _tmp23_;
		gfloat* _tmp24_;
		gint _tmp24__length1;
		gint _tmp25_;
		gfloat _tmp26_;
		gfloat* _tmp27_;
		gint _tmp27__length1;
		gint _tmp28_;
		gfloat _tmp29_;
		gdouble _tmp30_;
		gdouble _tmp31_ = 0.0;
		gfloat _tmp32_;
		_tmp20_ = self->in_i;
		_tmp21_ = last;
		if (!(_tmp20_ < _tmp21_)) {
			break;
		}
		_tmp22_ = out;
		_tmp22__length1 = out_length1;
		_tmp23_ = self->out_i;
		_tmp24_ = in;
		_tmp24__length1 = in_length1;
		_tmp25_ = self->in_i;
		_tmp26_ = _tmp24_[_tmp25_];
		_tmp27_ = in;
		_tmp27__length1 = in_length1;
		_tmp28_ = self->in_i;
		_tmp29_ = _tmp27_[_tmp28_ + 1];
		_tmp30_ = self->t;
		_tmp31_ = src_linear (self, (gdouble) _tmp26_, (gdouble) _tmp29_, _tmp30_);
		_tmp22_[_tmp23_] = (gfloat) _tmp31_;
		_tmp32_ = _tmp22_[_tmp23_];
		src_increment_time (self);
	}
	_tmp33_ = in;
	_tmp33__length1 = in_length1;
	_tmp34_ = last;
	_tmp35_ = _tmp33_[_tmp34_];
	self->rem = (gdouble) _tmp35_;
	_tmp36_ = self->time;
	_tmp37_ = last;
	self->time = (_tmp36_ - _tmp37_) - 1;
	_tmp38_ = self->out_i;
	result = _tmp38_;
	return result;
}


/**
   * Convert a chunk of data - cubic interpolation.
   * Returns the number of generated samples.
   */
gint src_cubic_convert (SRC* self, gfloat* in, int in_length1, gfloat* out, int out_length1) {
	gint result = 0;
	gdouble _tmp0_;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gfloat* _tmp52_;
	gint _tmp52__length1;
	gint last;
	gfloat* _tmp72_;
	gint _tmp72__length1;
	gint _tmp73_;
	gfloat _tmp74_;
	gdouble _tmp75_;
	gfloat* _tmp76_;
	gint _tmp76__length1;
	gint _tmp77_;
	gfloat _tmp78_;
	gdouble _tmp79_;
	gfloat* _tmp80_;
	gint _tmp80__length1;
	gint _tmp81_;
	gfloat _tmp82_;
	gdouble _tmp83_;
	gdouble _tmp84_;
	gint _tmp85_;
	gint _tmp86_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->ratio;
	_tmp1_ = in;
	_tmp1__length1 = in_length1;
	_tmp2_ = out;
	_tmp2__length1 = out_length1;
	if (((gint) (_tmp0_ * _tmp1__length1)) > _tmp2__length1) {
		FILE* _tmp3_;
		gdouble _tmp4_;
		gfloat* _tmp5_;
		gint _tmp5__length1;
		gfloat* _tmp6_;
		gint _tmp6__length1;
		_tmp3_ = stderr;
		_tmp4_ = self->ratio;
		_tmp5_ = in;
		_tmp5__length1 = in_length1;
		_tmp6_ = out;
		_tmp6__length1 = out_length1;
		fprintf (_tmp3_, "Output buffer is too small (need %i, buffer size %i).\n", (gint) (_tmp4_ * _tmp5__length1), _tmp6__length1);
		result = 0;
		return result;
	}
	src_reset_indices (self);
	while (TRUE) {
		gboolean _tmp7_ = FALSE;
		gdouble _tmp8_;
		gboolean _tmp10_;
		gfloat* _tmp11_;
		gint _tmp11__length1;
		gint _tmp12_;
		gdouble _tmp13_;
		gdouble _tmp14_;
		gdouble _tmp15_;
		gfloat* _tmp16_;
		gint _tmp16__length1;
		gfloat _tmp17_;
		gdouble _tmp18_;
		gdouble _tmp19_ = 0.0;
		gfloat _tmp20_;
		_tmp8_ = self->time;
		if (_tmp8_ < ((gdouble) (-1))) {
			gfloat* _tmp9_;
			gint _tmp9__length1;
			_tmp9_ = in;
			_tmp9__length1 = in_length1;
			_tmp7_ = _tmp9__length1 >= 1;
		} else {
			_tmp7_ = FALSE;
		}
		_tmp10_ = _tmp7_;
		if (!_tmp10_) {
			break;
		}
		_tmp11_ = out;
		_tmp11__length1 = out_length1;
		_tmp12_ = self->out_i;
		_tmp13_ = self->rems[0];
		_tmp14_ = self->rems[1];
		_tmp15_ = self->rems[2];
		_tmp16_ = in;
		_tmp16__length1 = in_length1;
		_tmp17_ = _tmp16_[0];
		_tmp18_ = self->time;
		_tmp19_ = src_cubic (self, _tmp13_, _tmp14_, _tmp15_, (gdouble) _tmp17_, _tmp18_ + 2);
		_tmp11_[_tmp12_] = (gfloat) _tmp19_;
		_tmp20_ = _tmp11_[_tmp12_];
		src_increment_time (self);
	}
	while (TRUE) {
		gboolean _tmp21_ = FALSE;
		gdouble _tmp22_;
		gboolean _tmp24_;
		gfloat* _tmp25_;
		gint _tmp25__length1;
		gint _tmp26_;
		gdouble _tmp27_;
		gdouble _tmp28_;
		gfloat* _tmp29_;
		gint _tmp29__length1;
		gfloat _tmp30_;
		gfloat* _tmp31_;
		gint _tmp31__length1;
		gfloat _tmp32_;
		gdouble _tmp33_;
		gdouble _tmp34_ = 0.0;
		gfloat _tmp35_;
		_tmp22_ = self->time;
		if (_tmp22_ < ((gdouble) 0)) {
			gfloat* _tmp23_;
			gint _tmp23__length1;
			_tmp23_ = in;
			_tmp23__length1 = in_length1;
			_tmp21_ = _tmp23__length1 >= 2;
		} else {
			_tmp21_ = FALSE;
		}
		_tmp24_ = _tmp21_;
		if (!_tmp24_) {
			break;
		}
		_tmp25_ = out;
		_tmp25__length1 = out_length1;
		_tmp26_ = self->out_i;
		_tmp27_ = self->rems[1];
		_tmp28_ = self->rems[2];
		_tmp29_ = in;
		_tmp29__length1 = in_length1;
		_tmp30_ = _tmp29_[0];
		_tmp31_ = in;
		_tmp31__length1 = in_length1;
		_tmp32_ = _tmp31_[1];
		_tmp33_ = self->time;
		_tmp34_ = src_cubic (self, _tmp27_, _tmp28_, (gdouble) _tmp30_, (gdouble) _tmp32_, _tmp33_ + 1);
		_tmp25_[_tmp26_] = (gfloat) _tmp34_;
		_tmp35_ = _tmp25_[_tmp26_];
		src_increment_time (self);
	}
	while (TRUE) {
		gboolean _tmp36_ = FALSE;
		gdouble _tmp37_;
		gboolean _tmp39_;
		gfloat* _tmp40_;
		gint _tmp40__length1;
		gint _tmp41_;
		gdouble _tmp42_;
		gfloat* _tmp43_;
		gint _tmp43__length1;
		gfloat _tmp44_;
		gfloat* _tmp45_;
		gint _tmp45__length1;
		gfloat _tmp46_;
		gfloat* _tmp47_;
		gint _tmp47__length1;
		gfloat _tmp48_;
		gdouble _tmp49_;
		gdouble _tmp50_ = 0.0;
		gfloat _tmp51_;
		_tmp37_ = self->time;
		if (_tmp37_ < ((gdouble) 1)) {
			gfloat* _tmp38_;
			gint _tmp38__length1;
			_tmp38_ = in;
			_tmp38__length1 = in_length1;
			_tmp36_ = _tmp38__length1 >= 3;
		} else {
			_tmp36_ = FALSE;
		}
		_tmp39_ = _tmp36_;
		if (!_tmp39_) {
			break;
		}
		_tmp40_ = out;
		_tmp40__length1 = out_length1;
		_tmp41_ = self->out_i;
		_tmp42_ = self->rems[2];
		_tmp43_ = in;
		_tmp43__length1 = in_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = in;
		_tmp45__length1 = in_length1;
		_tmp46_ = _tmp45_[1];
		_tmp47_ = in;
		_tmp47__length1 = in_length1;
		_tmp48_ = _tmp47_[2];
		_tmp49_ = self->time;
		_tmp50_ = src_cubic (self, _tmp42_, (gdouble) _tmp44_, (gdouble) _tmp46_, (gdouble) _tmp48_, _tmp49_);
		_tmp40_[_tmp41_] = (gfloat) _tmp50_;
		_tmp51_ = _tmp40_[_tmp41_];
		src_increment_time (self);
	}
	_tmp52_ = in;
	_tmp52__length1 = in_length1;
	last = _tmp52__length1 - 2;
	while (TRUE) {
		gint _tmp53_;
		gint _tmp54_;
		gfloat* _tmp55_;
		gint _tmp55__length1;
		gint _tmp56_;
		gfloat* _tmp57_;
		gint _tmp57__length1;
		gint _tmp58_;
		gfloat _tmp59_;
		gfloat* _tmp60_;
		gint _tmp60__length1;
		gint _tmp61_;
		gfloat _tmp62_;
		gfloat* _tmp63_;
		gint _tmp63__length1;
		gint _tmp64_;
		gfloat _tmp65_;
		gfloat* _tmp66_;
		gint _tmp66__length1;
		gint _tmp67_;
		gfloat _tmp68_;
		gdouble _tmp69_;
		gdouble _tmp70_ = 0.0;
		gfloat _tmp71_;
		_tmp53_ = self->in_i;
		_tmp54_ = last;
		if (!(_tmp53_ < _tmp54_)) {
			break;
		}
		_tmp55_ = out;
		_tmp55__length1 = out_length1;
		_tmp56_ = self->out_i;
		_tmp57_ = in;
		_tmp57__length1 = in_length1;
		_tmp58_ = self->in_i;
		_tmp59_ = _tmp57_[_tmp58_ - 1];
		_tmp60_ = in;
		_tmp60__length1 = in_length1;
		_tmp61_ = self->in_i;
		_tmp62_ = _tmp60_[_tmp61_];
		_tmp63_ = in;
		_tmp63__length1 = in_length1;
		_tmp64_ = self->in_i;
		_tmp65_ = _tmp63_[_tmp64_ + 1];
		_tmp66_ = in;
		_tmp66__length1 = in_length1;
		_tmp67_ = self->in_i;
		_tmp68_ = _tmp66_[_tmp67_ + 2];
		_tmp69_ = self->t;
		_tmp70_ = src_cubic (self, (gdouble) _tmp59_, (gdouble) _tmp62_, (gdouble) _tmp65_, (gdouble) _tmp68_, _tmp69_);
		_tmp55_[_tmp56_] = (gfloat) _tmp70_;
		_tmp71_ = _tmp55_[_tmp56_];
		src_increment_time (self);
	}
	_tmp72_ = in;
	_tmp72__length1 = in_length1;
	_tmp73_ = last;
	_tmp74_ = _tmp72_[_tmp73_ - 1];
	self->rems[0] = (gdouble) _tmp74_;
	_tmp75_ = self->rems[0];
	_tmp76_ = in;
	_tmp76__length1 = in_length1;
	_tmp77_ = last;
	_tmp78_ = _tmp76_[_tmp77_];
	self->rems[1] = (gdouble) _tmp78_;
	_tmp79_ = self->rems[1];
	_tmp80_ = in;
	_tmp80__length1 = in_length1;
	_tmp81_ = last;
	_tmp82_ = _tmp80_[_tmp81_ + 1];
	self->rems[2] = (gdouble) _tmp82_;
	_tmp83_ = self->rems[2];
	_tmp84_ = self->time;
	_tmp85_ = last;
	self->time = (_tmp84_ - _tmp85_) - 2;
	_tmp86_ = self->out_i;
	result = _tmp86_;
	return result;
}


void src_increment_time (SRC* self) {
	gdouble _tmp0_;
	gdouble _tmp1_;
	gint _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->time;
	_tmp1_ = self->interval;
	self->time = _tmp0_ + _tmp1_;
	_tmp2_ = self->out_i;
	self->out_i = _tmp2_ + 1;
	_tmp3_ = self->time;
	_tmp4_ = floor (_tmp3_);
	self->in_i = (gint) _tmp4_;
	_tmp5_ = self->time;
	_tmp6_ = self->in_i;
	self->t = _tmp5_ - _tmp6_;
}


void src_reset_indices (SRC* self) {
	gdouble _tmp0_;
	gdouble _tmp1_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->time;
	_tmp1_ = floor (_tmp0_);
	self->in_i = (gint) _tmp1_;
	self->out_i = 0;
}


/**
   * Linear interpolation
   */
gdouble src_linear (SRC* self, gdouble y0, gdouble y1, gdouble t) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = y0;
	_tmp1_ = t;
	_tmp2_ = y1;
	_tmp3_ = y0;
	result = _tmp0_ + (_tmp1_ * (_tmp2_ - _tmp3_));
	return result;
}


/**
   * Cubic interpolation
   */
gdouble src_cubic (SRC* self, gdouble y0, gdouble y1, gdouble y2, gdouble y3, gdouble t) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	gdouble _tmp7_;
	gdouble _tmp8_;
	gdouble _tmp9_;
	gdouble _tmp10_;
	gdouble _tmp11_;
	gdouble _tmp12_;
	gdouble _tmp13_;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = y1;
	_tmp1_ = y2;
	_tmp2_ = y1;
	_tmp3_ = y0;
	_tmp4_ = y3;
	_tmp5_ = t;
	_tmp6_ = y2;
	_tmp7_ = y3;
	_tmp8_ = y0;
	_tmp9_ = y1;
	_tmp10_ = t;
	_tmp11_ = y2;
	_tmp12_ = y0;
	_tmp13_ = t;
	result = _tmp0_ + (((((((((((-_tmp1_) * 3) / 2) + ((_tmp2_ * 3) / 2)) - (_tmp3_ / 2)) + (_tmp4_ / 2)) * _tmp5_) + ((((2 * _tmp6_) - (_tmp7_ / 2)) + _tmp8_) - ((_tmp9_ * 5) / 2))) * _tmp10_) + ((_tmp11_ - _tmp12_) / 2)) * _tmp13_);
	return result;
}


static void value_src_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_src_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		src_unref (value->data[0].v_pointer);
	}
}


static void value_src_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = src_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_src_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_src_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SRC* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = src_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_src_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SRC** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = src_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_src (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSRC* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SRC), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_src (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SRC), NULL);
	return value->data[0].v_pointer;
}


void value_set_src (GValue* value, gpointer v_object) {
	SRC* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SRC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SRC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		src_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		src_unref (old);
	}
}


void value_take_src (GValue* value, gpointer v_object) {
	SRC* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SRC));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SRC));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		src_unref (old);
	}
}


static void src_class_init (SRCClass * klass) {
	src_parent_class = g_type_class_peek_parent (klass);
	SRC_CLASS (klass)->finalize = src_finalize;
}


static void src_instance_init (SRC * self) {
	self->ref_count = 1;
}


static void src_finalize (SRC* obj) {
	SRC * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SRC, SRC);
}


/**
 * Sample rate converter
 */
GType src_get_type (void) {
	static volatile gsize src_type_id__volatile = 0;
	if (g_once_init_enter (&src_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_src_init, value_src_free_value, value_src_copy_value, value_src_peek_pointer, "p", value_src_collect_value, "p", value_src_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SRCClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) src_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SRC), 0, (GInstanceInitFunc) src_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType src_type_id;
		src_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SRC", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&src_type_id__volatile, src_type_id);
	}
	return src_type_id__volatile;
}


gpointer src_ref (gpointer instance) {
	SRC* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void src_unref (gpointer instance) {
	SRC* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SRC_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



