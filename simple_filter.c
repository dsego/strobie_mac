/* simple_filter.c generated by valac 0.18.1, the Vala compiler
 * generated from simple_filter.vala, do not modify */

/*
  Copyright (C) 2012 Davorin Å ego

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  of the Software, and to permit persons to whom the Software is furnished to do
  so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_FILTER (filter_get_type ())
#define FILTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FILTER, Filter))
#define FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FILTER, FilterClass))
#define IS_FILTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FILTER))
#define IS_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FILTER))
#define FILTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FILTER, FilterClass))

typedef struct _Filter Filter;
typedef struct _FilterClass FilterClass;
typedef struct _FilterPrivate FilterPrivate;
typedef struct _ParamSpecFilter ParamSpecFilter;

struct _Filter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	FilterPrivate * priv;
	gfloat* delayline;
	gint delayline_length1;
	gfloat* coeffs;
	gint coeffs_length1;
	gint numtaps;
	gint state;
};

struct _FilterClass {
	GTypeClass parent_class;
	void (*finalize) (Filter *self);
};

struct _ParamSpecFilter {
	GParamSpec parent_instance;
};


static gpointer filter_parent_class = NULL;

gpointer filter_ref (gpointer instance);
void filter_unref (gpointer instance);
GParamSpec* param_spec_filter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_filter (GValue* value, gpointer v_object);
void value_take_filter (GValue* value, gpointer v_object);
gpointer value_get_filter (const GValue* value);
GType filter_get_type (void) G_GNUC_CONST;
enum  {
	FILTER_DUMMY_PROPERTY
};
Filter* filter_new (gfloat* coefficients, int coefficients_length1);
Filter* filter_construct (GType object_type, gfloat* coefficients, int coefficients_length1);
static gfloat* _vala_array_dup3 (gfloat* self, int length);
gfloat filter_process (Filter* self, gfloat sample);
static void filter_finalize (Filter* obj);


/**
   * Construct a new filter
   */
static gfloat* _vala_array_dup3 (gfloat* self, int length) {
	return g_memdup (self, length * sizeof (gfloat));
}


Filter* filter_construct (GType object_type, gfloat* coefficients, int coefficients_length1) {
	Filter* self = NULL;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gfloat* _tmp1_;
	gint _tmp1__length1;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gfloat* _tmp4_ = NULL;
	gint _tmp5_;
	gint _tmp6_ = 0;
	gfloat* _tmp7_;
	gint _tmp7__length1;
	gint _tmp8_;
	gfloat* _tmp9_;
	gint _tmp9__length1;
	gint _tmp10_;
	self = (Filter*) g_type_create_instance (object_type);
	_tmp0_ = coefficients;
	_tmp0__length1 = coefficients_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup3 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->coeffs = (g_free (self->coeffs), NULL);
	self->coeffs = _tmp1_;
	self->coeffs_length1 = _tmp1__length1;
	_tmp2_ = self->coeffs;
	_tmp2__length1 = self->coeffs_length1;
	self->numtaps = _tmp2__length1;
	_tmp3_ = self->numtaps;
	_tmp4_ = g_new0 (gfloat, _tmp3_);
	self->delayline = (g_free (self->delayline), NULL);
	self->delayline = _tmp4_;
	self->delayline_length1 = _tmp3_;
	_tmp5_ = self->numtaps;
	_tmp6_ = _tmp5_ * 2;
	self->coeffs = g_renew (gfloat, self->coeffs, _tmp5_ * 2);
	(_tmp6_ > self->coeffs_length1) ? memset (self->coeffs + self->coeffs_length1, 0, sizeof (gfloat) * (_tmp6_ - self->coeffs_length1)) : NULL;
	self->coeffs_length1 = _tmp6_;
	_tmp7_ = self->coeffs;
	_tmp7__length1 = self->coeffs_length1;
	_tmp8_ = self->numtaps;
	_tmp9_ = self->coeffs;
	_tmp9__length1 = self->coeffs_length1;
	_tmp10_ = self->numtaps;
	memcpy (&_tmp7_[_tmp8_], _tmp9_, (gsize) (_tmp10_ * sizeof (gfloat)));
	return self;
}


Filter* filter_new (gfloat* coefficients, int coefficients_length1) {
	return filter_construct (TYPE_FILTER, coefficients, coefficients_length1);
}


/**
   * Process the input sample
   */
gfloat filter_process (Filter* self, gfloat sample) {
	gfloat result = 0.0F;
	gfloat _result_;
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint position;
	gint _tmp19_;
	gint _tmp20_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_result_ = 0.f;
	_tmp0_ = self->delayline;
	_tmp0__length1 = self->delayline_length1;
	_tmp1_ = self->state;
	_tmp2_ = sample;
	_tmp0_[_tmp1_] = _tmp2_;
	_tmp3_ = _tmp0_[_tmp1_];
	_tmp4_ = self->numtaps;
	_tmp5_ = self->state;
	position = _tmp4_ - _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				gint _tmp10_;
				gfloat _tmp11_;
				gfloat* _tmp12_;
				gint _tmp12__length1;
				gint _tmp13_;
				gfloat _tmp14_;
				gfloat* _tmp15_;
				gint _tmp15__length1;
				gint _tmp16_;
				gfloat _tmp17_;
				gint _tmp18_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = self->numtaps;
				if (!(_tmp9_ < _tmp10_)) {
					break;
				}
				_tmp11_ = _result_;
				_tmp12_ = self->delayline;
				_tmp12__length1 = self->delayline_length1;
				_tmp13_ = i;
				_tmp14_ = _tmp12_[_tmp13_];
				_tmp15_ = self->coeffs;
				_tmp15__length1 = self->coeffs_length1;
				_tmp16_ = position;
				_tmp17_ = _tmp15_[_tmp16_];
				_result_ = _tmp11_ + (_tmp14_ * _tmp17_);
				_tmp18_ = position;
				position = _tmp18_ + 1;
			}
		}
	}
	_tmp19_ = self->state;
	self->state = _tmp19_ - 1;
	_tmp20_ = self->state;
	if (_tmp20_ < 0) {
		gint _tmp21_;
		gint _tmp22_;
		_tmp21_ = self->state;
		_tmp22_ = self->numtaps;
		self->state = _tmp21_ + _tmp22_;
	}
	result = _result_;
	return result;
}


static void value_filter_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_filter_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		filter_unref (value->data[0].v_pointer);
	}
}


static void value_filter_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = filter_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_filter_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_filter_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Filter* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = filter_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_filter_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Filter** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = filter_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_filter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecFilter* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_FILTER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_filter (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FILTER), NULL);
	return value->data[0].v_pointer;
}


void value_set_filter (GValue* value, gpointer v_object) {
	Filter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FILTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FILTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		filter_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		filter_unref (old);
	}
}


void value_take_filter (GValue* value, gpointer v_object) {
	Filter* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_FILTER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_FILTER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		filter_unref (old);
	}
}


static void filter_class_init (FilterClass * klass) {
	filter_parent_class = g_type_class_peek_parent (klass);
	FILTER_CLASS (klass)->finalize = filter_finalize;
}


static void filter_instance_init (Filter * self) {
	self->state = 0;
	self->ref_count = 1;
}


static void filter_finalize (Filter* obj) {
	Filter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_FILTER, Filter);
	self->delayline = (g_free (self->delayline), NULL);
	self->coeffs = (g_free (self->coeffs), NULL);
}


/**
 * Finite Impulse Response Filter
 *
 * Algorithm copied from FirAlgs.c by Grant R. Griffin
 *
 * See: http://www.dspguru.com/dsp/faqs/fir/implementation
 *
 * Simulates a circular buffer by using a doubled coefficients array.
 * This way the filter operates on a flat buffer and avoids the use of
 * circular buffer logic or shuffling.
 *
 */
GType filter_get_type (void) {
	static volatile gsize filter_type_id__volatile = 0;
	if (g_once_init_enter (&filter_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_filter_init, value_filter_free_value, value_filter_copy_value, value_filter_peek_pointer, "p", value_filter_collect_value, "p", value_filter_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (FilterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) filter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Filter), 0, (GInstanceInitFunc) filter_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType filter_type_id;
		filter_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Filter", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&filter_type_id__volatile, filter_type_id);
	}
	return filter_type_id__volatile;
}


gpointer filter_ref (gpointer instance) {
	Filter* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void filter_unref (gpointer instance) {
	Filter* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		FILTER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



