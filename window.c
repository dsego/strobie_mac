/* window.c generated by valac 0.18.1, the Vala compiler
 * generated from window.vala, do not modify */

/*
  Copyright (C) 2012 Davorin Å ego

  Permission is hereby granted, free of charge, to any person obtaining a copy of
  this software and associated documentation files (the "Software"), to deal in
  the Software without restriction, including without limitation the rights to
  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
  of the Software, and to permit persons to whom the Software is furnished to do
  so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <gobject/gvaluecollector.h>


#define TYPE_WINDOW (window_get_type ())
#define WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WINDOW, Window))
#define WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WINDOW, WindowClass))
#define IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WINDOW))
#define IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WINDOW))
#define WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WINDOW, WindowClass))

typedef struct _Window Window;
typedef struct _WindowClass WindowClass;
typedef struct _WindowPrivate WindowPrivate;
typedef struct _ParamSpecWindow ParamSpecWindow;

struct _Window {
	GTypeInstance parent_instance;
	volatile int ref_count;
	WindowPrivate * priv;
};

struct _WindowClass {
	GTypeClass parent_class;
	void (*finalize) (Window *self);
};

struct _ParamSpecWindow {
	GParamSpec parent_instance;
};


static gpointer window_parent_class = NULL;

gpointer window_ref (gpointer instance);
void window_unref (gpointer instance);
GParamSpec* param_spec_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_window (GValue* value, gpointer v_object);
void value_take_window (GValue* value, gpointer v_object);
gpointer value_get_window (const GValue* value);
GType window_get_type (void) G_GNUC_CONST;
enum  {
	WINDOW_DUMMY_PROPERTY
};
void window_hamming (gfloat* response, int response_length1);
void window_hann (gfloat* response, int response_length1);
void window_blackman_harris (gfloat* response, int response_length1);
void window_cosine (gfloat* response, int response_length1);
void window_lanczos (gfloat* response, int response_length1);
void window_gaussian (gfloat* response, int response_length1);
Window* window_new (void);
Window* window_construct (GType object_type);
static void window_finalize (Window* obj);


void window_hamming (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gfloat c;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	c = 0.f;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				gdouble _tmp8_ = 0.0;
				gfloat* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				gfloat _tmp11_;
				gfloat _tmp12_;
				gfloat* _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				gint _tmp15_;
				gfloat _tmp16_;
				gfloat _tmp17_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = l;
				if (!(_tmp4_ <= (_tmp5_ / 2))) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = l;
				_tmp8_ = cos (((2.0 * G_PI) * _tmp6_) / _tmp7_);
				c = (gfloat) (0.54 - (0.46 * _tmp8_));
				_tmp9_ = response;
				_tmp9__length1 = response_length1;
				_tmp10_ = i;
				_tmp11_ = c;
				_tmp9_[_tmp10_] *= _tmp11_;
				_tmp12_ = _tmp9_[_tmp10_];
				_tmp13_ = response;
				_tmp13__length1 = response_length1;
				_tmp14_ = l;
				_tmp15_ = i;
				_tmp16_ = c;
				_tmp13_[_tmp14_ - _tmp15_] *= _tmp16_;
				_tmp17_ = _tmp13_[_tmp14_ - _tmp15_];
			}
		}
	}
}


void window_hann (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gfloat c;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	c = 0.f;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				gdouble _tmp8_ = 0.0;
				gfloat* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				gfloat _tmp11_;
				gfloat _tmp12_;
				gfloat* _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				gint _tmp15_;
				gfloat _tmp16_;
				gfloat _tmp17_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = l;
				if (!(_tmp4_ <= (_tmp5_ / 2))) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = l;
				_tmp8_ = cos (((2.0 * G_PI) * _tmp6_) / _tmp7_);
				c = (gfloat) (0.5 * (1.0 - _tmp8_));
				_tmp9_ = response;
				_tmp9__length1 = response_length1;
				_tmp10_ = i;
				_tmp11_ = c;
				_tmp9_[_tmp10_] *= _tmp11_;
				_tmp12_ = _tmp9_[_tmp10_];
				_tmp13_ = response;
				_tmp13__length1 = response_length1;
				_tmp14_ = l;
				_tmp15_ = i;
				_tmp16_ = c;
				_tmp13_[_tmp14_ - _tmp15_] *= _tmp16_;
				_tmp17_ = _tmp13_[_tmp14_ - _tmp15_];
			}
		}
	}
}


void window_blackman_harris (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gfloat c;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	c = 0.f;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				gdouble _tmp8_ = 0.0;
				gint _tmp9_;
				gint _tmp10_;
				gdouble _tmp11_ = 0.0;
				gint _tmp12_;
				gint _tmp13_;
				gdouble _tmp14_ = 0.0;
				gfloat* _tmp15_;
				gint _tmp15__length1;
				gint _tmp16_;
				gfloat _tmp17_;
				gfloat _tmp18_;
				gfloat* _tmp19_;
				gint _tmp19__length1;
				gint _tmp20_;
				gint _tmp21_;
				gfloat _tmp22_;
				gfloat _tmp23_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = l;
				if (!(_tmp4_ <= (_tmp5_ / 2))) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = l;
				_tmp8_ = cos (((2 * G_PI) * _tmp6_) / _tmp7_);
				_tmp9_ = i;
				_tmp10_ = l;
				_tmp11_ = cos (((4 * G_PI) * _tmp9_) / _tmp10_);
				_tmp12_ = i;
				_tmp13_ = l;
				_tmp14_ = cos (((6 * G_PI) * _tmp12_) / _tmp13_);
				c = (gfloat) (((0.35875 - (0.48829 * _tmp8_)) + (0.14128 * _tmp11_)) + (0.01168 * _tmp14_));
				_tmp15_ = response;
				_tmp15__length1 = response_length1;
				_tmp16_ = i;
				_tmp17_ = c;
				_tmp15_[_tmp16_] *= _tmp17_;
				_tmp18_ = _tmp15_[_tmp16_];
				_tmp19_ = response;
				_tmp19__length1 = response_length1;
				_tmp20_ = l;
				_tmp21_ = i;
				_tmp22_ = c;
				_tmp19_[_tmp20_ - _tmp21_] *= _tmp22_;
				_tmp23_ = _tmp19_[_tmp20_ - _tmp21_];
			}
		}
	}
}


void window_cosine (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gfloat c;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	c = 0.f;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				gdouble _tmp8_ = 0.0;
				gfloat* _tmp9_;
				gint _tmp9__length1;
				gint _tmp10_;
				gfloat _tmp11_;
				gfloat _tmp12_;
				gfloat* _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				gint _tmp15_;
				gfloat _tmp16_;
				gfloat _tmp17_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = l;
				if (!(_tmp4_ <= (_tmp5_ / 2))) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = l;
				_tmp8_ = sin ((G_PI * _tmp6_) / _tmp7_);
				c = (gfloat) _tmp8_;
				_tmp9_ = response;
				_tmp9__length1 = response_length1;
				_tmp10_ = i;
				_tmp11_ = c;
				_tmp9_[_tmp10_] *= _tmp11_;
				_tmp12_ = _tmp9_[_tmp10_];
				_tmp13_ = response;
				_tmp13__length1 = response_length1;
				_tmp14_ = l;
				_tmp15_ = i;
				_tmp16_ = c;
				_tmp13_[_tmp14_ - _tmp15_] *= _tmp16_;
				_tmp17_ = _tmp13_[_tmp14_ - _tmp15_];
			}
		}
	}
}


void window_lanczos (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gint _tmp1_;
	gint h;
	gfloat c;
	gfloat* _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gfloat _tmp4_;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	_tmp1_ = l;
	h = _tmp1_ / 2;
	c = 0.f;
	_tmp2_ = response;
	_tmp2__length1 = response_length1;
	_tmp3_ = h;
	_tmp2_[_tmp3_] = 1.f;
	_tmp4_ = _tmp2_[_tmp3_];
	{
		gint i;
		i = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				gboolean _tmp6_;
				gint _tmp8_;
				gint _tmp9_;
				gint _tmp10_;
				gint _tmp11_;
				gfloat _tmp12_;
				gdouble _tmp13_ = 0.0;
				gfloat _tmp14_;
				gfloat* _tmp15_;
				gint _tmp15__length1;
				gint _tmp16_;
				gfloat _tmp17_;
				gfloat _tmp18_;
				gfloat* _tmp19_;
				gint _tmp19__length1;
				gint _tmp20_;
				gint _tmp21_;
				gfloat _tmp22_;
				gfloat _tmp23_;
				_tmp6_ = _tmp5_;
				if (!_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp8_ = i;
				_tmp9_ = h;
				if (!(_tmp8_ < _tmp9_)) {
					break;
				}
				_tmp10_ = i;
				_tmp11_ = l;
				c = (gfloat) (G_PI * (((2 * ((gfloat) _tmp10_)) / _tmp11_) - 1));
				_tmp12_ = c;
				_tmp13_ = sin ((gdouble) _tmp12_);
				_tmp14_ = c;
				c = ((gfloat) _tmp13_) / _tmp14_;
				_tmp15_ = response;
				_tmp15__length1 = response_length1;
				_tmp16_ = i;
				_tmp17_ = c;
				_tmp15_[_tmp16_] *= _tmp17_;
				_tmp18_ = _tmp15_[_tmp16_];
				_tmp19_ = response;
				_tmp19__length1 = response_length1;
				_tmp20_ = l;
				_tmp21_ = i;
				_tmp22_ = c;
				_tmp19_[_tmp20_ - _tmp21_] *= _tmp22_;
				_tmp23_ = _tmp19_[_tmp20_ - _tmp21_];
			}
		}
	}
}


void window_gaussian (gfloat* response, int response_length1) {
	gfloat* _tmp0_;
	gint _tmp0__length1;
	gint l;
	gfloat c;
	gdouble exp;
	gdouble sigma;
	_tmp0_ = response;
	_tmp0__length1 = response_length1;
	l = _tmp0__length1 - 1;
	c = 0.f;
	exp = 0.0;
	sigma = 0.4;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				gdouble _tmp8_;
				gint _tmp9_;
				gdouble _tmp10_;
				gdouble _tmp11_;
				gdouble _tmp12_ = 0.0;
				gfloat* _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				gfloat _tmp15_;
				gfloat _tmp16_;
				gfloat* _tmp17_;
				gint _tmp17__length1;
				gint _tmp18_;
				gint _tmp19_;
				gfloat _tmp20_;
				gfloat _tmp21_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = l;
				if (!(_tmp4_ <= (_tmp5_ / 2))) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = l;
				_tmp8_ = sigma;
				_tmp9_ = l;
				exp = (_tmp6_ - (_tmp7_ / 2)) / ((_tmp8_ * _tmp9_) / 2);
				_tmp10_ = exp;
				_tmp11_ = exp;
				_tmp12_ = pow (G_E, ((-0.5) * _tmp10_) * _tmp11_);
				c = (gfloat) _tmp12_;
				_tmp13_ = response;
				_tmp13__length1 = response_length1;
				_tmp14_ = i;
				_tmp15_ = c;
				_tmp13_[_tmp14_] *= _tmp15_;
				_tmp16_ = _tmp13_[_tmp14_];
				_tmp17_ = response;
				_tmp17__length1 = response_length1;
				_tmp18_ = l;
				_tmp19_ = i;
				_tmp20_ = c;
				_tmp17_[_tmp18_ - _tmp19_] *= _tmp20_;
				_tmp21_ = _tmp17_[_tmp18_ - _tmp19_];
			}
		}
	}
}


Window* window_construct (GType object_type) {
	Window* self = NULL;
	self = (Window*) g_type_create_instance (object_type);
	return self;
}


Window* window_new (void) {
	return window_construct (TYPE_WINDOW);
}


static void value_window_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_window_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		window_unref (value->data[0].v_pointer);
	}
}


static void value_window_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = window_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_window_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_window_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Window* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = window_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_window_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Window** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = window_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_window (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecWindow* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_WINDOW), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_window (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WINDOW), NULL);
	return value->data[0].v_pointer;
}


void value_set_window (GValue* value, gpointer v_object) {
	Window* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		window_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		window_unref (old);
	}
}


void value_take_window (GValue* value, gpointer v_object) {
	Window* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_WINDOW));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_WINDOW));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		window_unref (old);
	}
}


static void window_class_init (WindowClass * klass) {
	window_parent_class = g_type_class_peek_parent (klass);
	WINDOW_CLASS (klass)->finalize = window_finalize;
}


static void window_instance_init (Window * self) {
	self->ref_count = 1;
}


static void window_finalize (Window* obj) {
	Window * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_WINDOW, Window);
}


GType window_get_type (void) {
	static volatile gsize window_type_id__volatile = 0;
	if (g_once_init_enter (&window_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_window_init, value_window_free_value, value_window_copy_value, value_window_peek_pointer, "p", value_window_collect_value, "p", value_window_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (WindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Window), 0, (GInstanceInitFunc) window_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType window_type_id;
		window_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Window", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&window_type_id__volatile, window_type_id);
	}
	return window_type_id__volatile;
}


gpointer window_ref (gpointer instance) {
	Window* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void window_unref (gpointer instance) {
	Window* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		WINDOW_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



